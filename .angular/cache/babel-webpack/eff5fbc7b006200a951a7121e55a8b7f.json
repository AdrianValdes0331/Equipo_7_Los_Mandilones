{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/pingu/Documents/Tec/Carrera Tec sem 6/parcial_2/Cemex_Materiales/Cemex_Login_V1.0/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { r as registerInstance, c as createEvent, h, g as getElement } from './core-85189c77.js';\nimport { i as initBasics, d as destroyBasics } from './commonComponentFeatures-b771e888.js';\nvar NavigationKeys = /*#__PURE__*/(() => {\n  (function (NavigationKeys) {\n    NavigationKeys[\"ArrowUp\"] = \"ArrowUp\";\n    NavigationKeys[\"ArrowDown\"] = \"ArrowDown\";\n    NavigationKeys[\"Enter\"] = \"Enter\";\n    NavigationKeys[\"Escape\"] = \"Escape\";\n  })(NavigationKeys || (NavigationKeys = {}));\n\n  return NavigationKeys;\n})();\nconst InputDatalist = class {\n  constructor(hostRef) {\n    registerInstance(this, hostRef);\n    this.hiddenOptions = [];\n    this.selectedOption = null;\n    this.layerStyle = {};\n    this.orientation = 'nn';\n    /**\n     * Input value\n     */\n\n    this.value = null;\n    /**\n     * The design version of the framework\n     */\n\n    this.designVersion = null;\n    /**\n     * Input label\n     */\n\n    this.label = '';\n    /**\n     * Input value palceholder\n     */\n\n    this.placeholder = 'Select Time';\n    /**\n     * When set, then debounce time will be applied after user writes into the input\n     * (in miliseconds)\n     */\n\n    this.debounceTime = 0;\n    /**\n     * Specify whether component should render from right to left\n     */\n\n    this.rtl = false;\n    /**\n     * When set to true the element is disabled\n     */\n\n    this.disabled = false;\n    /**\n     * When set to true cwc-loader is displayed at the end of the field\n     */\n\n    this.loading = false;\n    /**\n     * When set to true the element is required and the label is decorated with an asterisk (*)\n     */\n\n    this.required = false;\n    /**\n     * Status of the form field.\n     */\n\n    this.status = 'regular';\n    /**\n     * Warning message shown when no results were found in the datalist\n     */\n\n    this.noResultsWarningMessage = '';\n    /**\n     * Icon of the warning message\n     */\n\n    this.noResultsWarningIcon = 'information-rounded-fill';\n    /**\n     * Icon of the warning message\n     */\n\n    this.noResultsWarningIconColor = 'bright-orange';\n    /**\n     * Disables the filtering in UI\n     */\n\n    this.disableFilter = false;\n    /**\n     * Specify if input label should render for mobile\n     */\n\n    this.mobile = false;\n    /**\n     * Specify the minWidth of the layer in CSS units\n     */\n\n    this.minWidth = 'auto';\n    /**\n     * Specify the maxHeight of the layer in CSS units\n     */\n\n    this.maxHeight = 'auto';\n    /**\n     * Stores the position of the selected option for keyboard navigation\n     */\n\n    this.selectedOptionIndex = -1;\n    /**\n     * Defines whether user just clicked on one of the options\n     */\n\n    this.optionWasJustClicked = false;\n    /**\n     * Defines if the window with options should be shown\n     */\n\n    this.showDatalist = false;\n    this.allDatalistOptions = [];\n\n    this.onClick = () => {\n      if (!this.disabled && (!this.allOptionsHidden || this.hasAWarningMessage)) {\n        this.showDatalist = true;\n      }\n\n      this.positionOverlay();\n    };\n\n    this.onChange = ev => {\n      ev.stopPropagation();\n      this.optionWasJustClicked = false;\n\n      if (ev.detail === null) {\n        return;\n      }\n\n      this.controlValue = ev.detail;\n      this.cwcChange.emit(this.controlValue);\n    };\n\n    this.onInput = ev => {\n      ev.stopPropagation();\n      this.cwcInput.emit(ev.detail);\n    };\n\n    this.onBlur = ev => {\n      ev.stopPropagation();\n      this.cwcBlur.emit();\n    };\n\n    this.onFocus = ev => {\n      ev.stopPropagation();\n      this.cwcFocus.emit();\n    };\n\n    this.setLayerStyle = layerStyles => {\n      const oldValues = this.layerStyle;\n      this.layerStyle = Object.assign(Object.assign({}, oldValues), layerStyles);\n    };\n\n    this.hideOverlay = () => {\n      this.showDatalist = false;\n    };\n\n    this.positionOverlay = () => {\n      // find position on screen\n      const elementDimensions = this.targetElement.getBoundingClientRect(); // get overlay dimensions\n\n      const layerDimensions = this.layer.getBoundingClientRect(); // get window width and height\n\n      const windowDimensions = {\n        width: document.documentElement.clientWidth,\n        height: document.documentElement.clientHeight\n      }; // define base overlay style\n\n      const layerStyle = {\n        width: this.layerStyle.width,\n        height: 'auto',\n        left: '',\n        top: '',\n        pointerEvents: this.showDatalist ? 'all' : 'none',\n        minWidth: this.minWidth,\n        maxHeight: this.maxHeight\n      };\n      let caseString;\n      let flow;\n      let lateralOverflow;\n      let verticalOverflow;\n      /*\n      EXPLANATION OF NOMENCLATURE\n               When organizing the direction that the overlay has to go\n      the class names were chosen around the positive/negative orientation for each axis\n      therefore, a class name of 'pp' means that the overlay is flowing\n      positively horizontally (to the start) and positively vertically (upwards).\n      This also means that a class name of 'nn' determines that\n      the overlay should open negatively horizontally (to the end) and negatively vertically (downwards).\n               All calsses are build using this logic.\n      */\n\n      const positionAdjustment = this.mobile ? 40 : 60;\n\n      if (this.direction) {\n        flow = 'ltr';\n        const directionArray = this.direction.split('');\n        caseString = (directionArray[1] === 'w' ? 'p' : 'n') + (directionArray[0] === 'n' ? 'p' : 'n');\n      } else {\n        if (!this.rtl) {\n          // calculate if overflows\n          lateralOverflow = elementDimensions.left + layerDimensions.width - windowDimensions.width;\n          verticalOverflow = elementDimensions.top + layerDimensions.height - windowDimensions.height + positionAdjustment; // define the overflow scenario for a particular class and the positioning switch\n          // display overlay downwards when window heigh is smaller than the overlay\n\n          caseString = windowDimensions.height < layerDimensions.height ? (lateralOverflow > 0 ? 'p' : 'n') + 'n' : (lateralOverflow > 0 ? 'p' : 'n') + (verticalOverflow > 0 ? 'p' : 'n');\n          flow = 'ltr';\n        } else {\n          // calculate if overflows\n          lateralOverflow = elementDimensions.right - layerDimensions.width;\n          verticalOverflow = elementDimensions.top + layerDimensions.height - windowDimensions.height + positionAdjustment; // define the overflow scenario for a particular class and the positioning switch\n          // display overlay downwards when window heigh is smaller than the overlay\n\n          caseString = windowDimensions.height < layerDimensions.height ? (lateralOverflow < 0 ? 'p' : 'n') + 'n' : (lateralOverflow < 0 ? 'p' : 'n') + (verticalOverflow > 0 ? 'p' : 'n');\n          flow = 'rtl';\n        }\n      } // get the top left values with the orientation string\n\n\n      const topleft = this.getOrientation(`${flow}_${caseString}`, elementDimensions, layerDimensions); // assign the new layer style\n\n      this.layerStyle = Object.assign(Object.assign({}, layerStyle), topleft); // assign the orientation for custom orientation classes\n\n      this.orientation = caseString;\n    };\n\n    this.cwcInput = createEvent(this, \"cwcInput\", 7);\n    this.cwcChange = createEvent(this, \"cwcChange\", 7);\n    this.cwcBlur = createEvent(this, \"cwcBlur\", 7);\n    this.cwcFocus = createEvent(this, \"cwcFocus\", 7);\n  }\n\n  setValue(newValue) {\n    this.controlValue = newValue;\n  }\n\n  onControlValueChange() {\n    this.value = this.controlValue;\n\n    if (!this.disableFilter) {\n      this.filterDatalistOptions();\n    }\n  }\n\n  handleLayerPosition(newValue) {\n    if (newValue === true) {\n      this.setLayerStyle({\n        pointerEvents: 'all'\n      });\n      setTimeout(() => {\n        document.addEventListener('scroll', this.hideOverlay, true);\n        document.addEventListener('cwcScroll', this.hideOverlay, true);\n        window.addEventListener('resize', this.hideOverlay);\n      });\n    } else {\n      this.setLayerStyle({\n        pointerEvents: 'none'\n      });\n      document.removeEventListener('scroll', this.hideOverlay, true);\n      document.removeEventListener('cwcScroll', this.hideOverlay, true);\n      window.removeEventListener('resize', this.hideOverlay);\n    }\n  }\n  /**\n   * Listens to click outside the component and hides the datalist\n   * @param event Event Details\n   */\n\n\n  handleClick(event) {\n    if (this.showDatalist && !this.host.contains(event.target)) {\n      this.showDatalist = false;\n    }\n  }\n  /**\n   * Triggered when option is selected. Event emitted in cwc-input-datalist-option\n   * @param event Event details\n   */\n\n\n  optionSelectedHandler(event) {\n    event.stopPropagation();\n    this.controlValue = event.detail;\n    this.cwcChange.emit(this.controlValue); // find index of the option selected\n\n    const optionsArray = Array.from(this.host.querySelectorAll('cwc-input-datalist-option')); // assign selected index\n\n    this.selectedOption = null;\n\n    for (let i = 0; i < optionsArray.length; i++) {\n      if (optionsArray[i] === event.srcElement) {\n        this.selectedOption = event.srcElement;\n        break;\n      }\n    } // Change in input triggers showDatalist, therefore using timeout to hide it right away\n\n\n    setTimeout(() => {\n      this.showDatalist = false;\n      this.optionWasJustClicked = true;\n    }, 100);\n  }\n  /**\n   * Listens to keydown for keyboard navigation\n   * @param event Event Details\n   */\n\n\n  handleKeyDown(event) {\n    if (event.key in NavigationKeys) {\n      this.navigateWithKeyboard(NavigationKeys[event.key]);\n    }\n  }\n  /**\n   * Register option when it is hits the DOM.\n   * @param element The option element\n   */\n\n\n  registerOption(element) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      _this.allDatalistOptions = [..._this.allDatalistOptions, element];\n\n      _this.sortDatalistOptions();\n\n      if (_this.controlValue) {\n        _this.setHiddenOptions();\n      }\n\n      _this.allOptionsHidden = _this.hiddenOptions.length === _this.allDatalistOptions.length;\n    })();\n  }\n  /**\n   * Get the selected option\n   */\n\n\n  getSelectedOption() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      return _this2.selectedOption;\n    })();\n  }\n  /**\n   * Unregister option when it is removed from the DOM\n   * @param element The option element\n   */\n\n\n  unregisterOption(element) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      _this3.allDatalistOptions = _this3.allDatalistOptions.filter(optionEl => optionEl !== element);\n\n      _this3.setHiddenOptions();\n    })();\n  }\n  /**\n   * Set component value and emit cwcChange event. This is handy for emulating user input in automated testing tools.\n   * @param value New value\n   */\n\n\n  writeValue(value) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      _this4.controlValue = value;\n\n      _this4.cwcChange.emit(_this4.controlValue);\n    })();\n  }\n  /**\n   * Sorts options in allDatalistOptions variable\n   * These options are registered in different order than in which they are in DOM\n   * This right order enables the navigation with keys up & down\n   */\n\n\n  sortDatalistOptions() {\n    const optionsFromUI = Array.from(this.host.getElementsByTagName('cwc-input-datalist-option'));\n    this.allDatalistOptions.forEach(option => {\n      option['position'] = optionsFromUI.indexOf(option);\n    });\n    this.allDatalistOptions.sort((a, b) => a['position'] - b['position']);\n  }\n  /**\n   * Navigates the data list with the keyboard\n   * @param key Event key value\n   *\n   */\n\n\n  navigateWithKeyboard(key) {\n    const keyboardNavigationMap = new Map([[NavigationKeys.ArrowUp, () => this.navigateWithArrowsKeys(NavigationKeys.ArrowUp)], [NavigationKeys.ArrowDown, () => this.navigateWithArrowsKeys(NavigationKeys.ArrowDown)], [NavigationKeys.Enter, () => this.selectOption()], [NavigationKeys.Escape, () => this.showDatalist = false]]);\n    keyboardNavigationMap.get(key)();\n  }\n\n  navigateWithArrowsKeys(key) {\n    const visibleOptions = this.allDatalistOptions.filter(({\n      hidden\n    }) => !hidden);\n    const step = key === NavigationKeys.ArrowDown ? 1 : visibleOptions.length - 1;\n    this.allDatalistOptions.forEach(optionEl => optionEl.selected = false);\n    this.selectedOptionIndex = (this.selectedOptionIndex + step) % visibleOptions.length;\n    const option = visibleOptions[this.selectedOptionIndex];\n    option.selected = true;\n    option.scrollIntoView({\n      behavior: 'smooth',\n      block: 'nearest',\n      inline: 'start'\n    });\n  }\n\n  selectOption() {\n    const visibleOptions = this.allDatalistOptions.filter(({\n      hidden\n    }) => !hidden);\n    const selectedOption = visibleOptions[this.selectedOptionIndex];\n    if (selectedOption) selectedOption.selectOption();\n  }\n\n  get hasAnEmptyList() {\n    return this.allDatalistOptions.length === 0;\n  }\n\n  get justClickedOnSelectOption() {\n    return this.allDatalistOptions.length === 1 && this.allDatalistOptions[0].textContent === this.controlValue && this.optionWasJustClicked;\n  }\n  /**\n   * Hide options window when\n   * - datalist is false\n   * - options are empty and warning message is not set\n   * - user just clicked on the option\n   */\n\n\n  get hideOptionsWindow() {\n    return !this.showDatalist || this.hasAnEmptyList && !this.showWarningMessage || this.justClickedOnSelectOption;\n  }\n\n  setHiddenOptions() {\n    this.hiddenOptions = this.allDatalistOptions.filter(optionEl => optionEl.textContent.toUpperCase().indexOf(this.controlValue.toUpperCase()) < 0);\n    this.allDatalistOptions.forEach(optionEl => {\n      optionEl.showOption();\n      optionEl.hidden = false;\n    });\n    this.hiddenOptions.forEach(optionEl => {\n      optionEl.hideOption();\n      optionEl.hidden = true;\n    });\n  }\n\n  componentWillLoad() {\n    initBasics(this);\n  }\n\n  componentDidLoad() {\n    if (this.value) {\n      this.controlValue = this.value;\n    }\n\n    this.positionOverlay();\n  }\n\n  disconnectedCallback() {\n    destroyBasics(this);\n  }\n  /**\n   * Display only options matching search string\n   */\n\n\n  filterDatalistOptions() {\n    this.setHiddenOptions();\n    const visibleOptions = this.allDatalistOptions.filter(({\n      hidden\n    }) => !hidden);\n\n    if (visibleOptions.length) {\n      this.selectedOptionIndex = 0;\n      visibleOptions[this.selectedOptionIndex].selected = true;\n    }\n\n    this.allOptionsHidden = this.hiddenOptions.length === this.allDatalistOptions.length;\n    this.showDatalist = !this.allOptionsHidden || this.showWarningMessage;\n  }\n\n  get hasAWarningMessage() {\n    return this.noResultsWarningMessage.length > 0;\n  }\n  /**\n   * Warning message is show when it is set and when no option matches the control value\n   */\n\n\n  get showWarningMessage() {\n    return this.hasAWarningMessage && !!this.controlValue && this.allOptionsHidden;\n  }\n\n  getOrientation(key, elementDimensions, layerDimensions) {\n    const formulas = new Map();\n    const ajdustLayerPosition = this.mobile ? 0 : 20;\n    formulas.set('ltr_pn', {\n      left: elementDimensions.left + elementDimensions.width - layerDimensions.width + 'px',\n      top: elementDimensions.top + elementDimensions.height - 20 + 'px'\n    });\n    formulas.set('ltr_np', {\n      left: elementDimensions.left + 'px',\n      top: elementDimensions.top - layerDimensions.height + ajdustLayerPosition + 'px'\n    });\n    formulas.set('ltr_pp', {\n      left: elementDimensions.left + elementDimensions.width - layerDimensions.width + 'px',\n      top: elementDimensions.top - layerDimensions.height + ajdustLayerPosition + 'px'\n    });\n    formulas.set('ltr_nn', {\n      left: elementDimensions.left + 'px',\n      top: elementDimensions.top + elementDimensions.height - 20 + 'px'\n    });\n    formulas.set('rtl_pn', {\n      left: elementDimensions.left + 'px',\n      top: elementDimensions.top + elementDimensions.height - 20 + 'px'\n    });\n    formulas.set('rtl_np', {\n      left: elementDimensions.left + elementDimensions.width - layerDimensions.width + 'px',\n      top: elementDimensions.top - layerDimensions.height + ajdustLayerPosition + 'px'\n    });\n    formulas.set('rtl_pp', {\n      left: elementDimensions.left + 'px',\n      top: elementDimensions.top - layerDimensions.height + ajdustLayerPosition + 'px'\n    });\n    formulas.set('rtl_nn', {\n      left: elementDimensions.left + elementDimensions.width - layerDimensions.width + 'px',\n      top: elementDimensions.top + elementDimensions.height - 20 + 'px'\n    });\n    return formulas.get(key);\n  }\n\n  render() {\n    const warningMessage = this.showWarningMessage ? h(\"div\", {\n      class: \"cwc-input-datalist__warning-message\"\n    }, h(\"cwc-icon\", {\n      name: this.noResultsWarningIcon,\n      size: \"3rem\",\n      color: this.noResultsWarningIconColor\n    }), h(\"p\", null, this.noResultsWarningMessage)) : null;\n    const datalistItems = h(\"div\", {\n      class: 'cwc-overlay' + (this.hideOptionsWindow ? ' hidden' : '') + ' ' + this.orientation,\n      ref: el => this.layer = el,\n      style: this.layerStyle,\n      role: \"dialog\"\n    }, warningMessage, h(\"div\", {\n      role: \"listbox\",\n      \"aria-expanded\": !this.hideOptionsWindow,\n      \"aria-readonly\": true,\n      \"aria-disabled\": this.disableFilter\n    }, h(\"slot\", null)));\n    return h(\"div\", {\n      class: `cwc-input-datalist ${this.designVersion}`\n    }, h(\"cwc-input\", {\n      placeholder: this.placeholder,\n      value: this.controlValue,\n      disabled: this.disabled,\n      required: this.required,\n      status: this.status,\n      statusMessage: this.statusMessage,\n      label: this.label,\n      \"debounce-time\": this.debounceTime,\n      maxlength: this.maxlength,\n      loading: this.loading,\n      onClick: this.onClick,\n      onCwcChange: this.onChange,\n      onCwcInput: this.onInput,\n      onCwcFocus: this.onFocus,\n      onCwcBlur: this.onBlur,\n      style: {\n        width: '100%'\n      },\n      mobile: this.mobile,\n      ref: el => this.targetElement = el,\n      designVersion: this.designVersion\n    }), datalistItems);\n  }\n\n  get host() {\n    return getElement(this);\n  }\n\n  static get watchers() {\n    return {\n      \"value\": [\"setValue\"],\n      \"controlValue\": [\"onControlValueChange\"],\n      \"showDatalist\": [\"handleLayerPosition\"]\n    };\n  }\n\n  static get style() {\n    return \"*{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}:host{display:inline-block}.cwc-input-datalist{position:relative;font-family:inherit}.cwc-input-datalist__options{background:var(--cwc-input-datalist-background-color,var(--cwc-color-grayscale-white,#fff));border-radius:3px;-webkit-box-shadow:0 8px 13px rgba(0,0,0,.3);box-shadow:0 8px 13px rgba(0,0,0,.3);max-height:220px;display:-ms-flexbox;display:flex;-ms-flex-direction:column;flex-direction:column;position:absolute;width:100%;min-width:250px;-webkit-box-sizing:border-box;box-sizing:border-box;z-index:3001;margin-top:-1.25rem;padding:15px 0;overflow-x:hidden;overflow-y:auto;-webkit-transition:max-height .5s,padding .5s;transition:max-height .5s,padding .5s;background-repeat:no-repeat;background-image:var(--cwc-input-datalist-background-image,var(--cwc-color-ui-highlight-gradient,url(data:image/svg+xml,%3Csvg%20width%3D%2210%22%20height%3D%2210%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%3Cpath%20fill%3D%22%233FA9F5%22%20d%3D%22M0%200h10v10H0z%22%2F%3E%3C%2Fsvg%3E)));background-size:100% 3px;background-position:0 0}.cwc-input-datalist__options.animation{-webkit-animation:activate .35s linear 1;animation:activate .35s linear 1}.cwc-input-datalist__options.hidden{max-height:0;padding:0;border:none;-webkit-animation:deactivate .35s linear 1;animation:deactivate .35s linear 1;-webkit-animation-fill-mode:forwards;animation-fill-mode:forwards;background-position:100% 0}.cwc-input-datalist__options__wrapper{direction:ltr!important;height:5.4em;display:-ms-flexbox;display:flex;-ms-flex-pack:center;justify-content:center;width:100%;max-width:150px;margin:auto}.cwc-input-datalist__options__text{text-align:center;border:0;outline:medium none;padding:10px 0;color:var(--cwc-input-datalist-text-color,var(--cwc-color-grayscale-dark,#333));-webkit-transition:.2s;transition:.2s;font-size:1rem;font-weight:400}.cwc-input-datalist__warning-message{text-align:center;padding:1.5rem 1rem;max-width:300px}.cwc-input-datalist__warning-message p{font-size:.75rem;color:var(--cwc-input-datalist-warning-message-color,var(--cwc-color-grayscale-dark,#333));margin:.5rem 0 0}::-webkit-scrollbar-track{background:transparent}::-webkit-scrollbar-thumb{background-image:url(\\\"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iOCIgaGVpZ2h0PSI0IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxwYXRoIGQ9Ik0wIDRhNCA0IDAgMSAxIDggMEgweiIgZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBmaWxsLW9wYWNpdHk9Ii40Ii8+PC9zdmc+\\\"),url(\\\"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iOCIgaGVpZ2h0PSI0IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxwYXRoIGQ9Ik0wIDBhNCA0IDAgMSAwIDggMEgweiIgZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBmaWxsLW9wYWNpdHk9Ii40Ii8+PC9zdmc+\\\"),url(\\\"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iOCIgaGVpZ2h0PSI4IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxwYXRoIGZpbGw9IiMwMDAiIGQ9Ik0wIDBoOHY4SDB6IiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGZpbGwtb3BhY2l0eT0iLjQiLz48L3N2Zz4=\\\");background-repeat:no-repeat,no-repeat,no-repeat;background-position:top,bottom,50%;background-size:auto,auto,8px calc(100% - 8px)}::-webkit-scrollbar-thumb:hover{background-image:url(\\\"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iOCIgaGVpZ2h0PSI0IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxwYXRoIGQ9Ik0wIDRhNCA0IDAgMSAxIDggMEgweiIgZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBmaWxsLW9wYWNpdHk9Ii42Ii8+PC9zdmc+\\\"),url(\\\"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iOCIgaGVpZ2h0PSI0IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxwYXRoIGQ9Ik0wIDBhNCA0IDAgMSAwIDggMEgweiIgZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBmaWxsLW9wYWNpdHk9Ii42Ii8+PC9zdmc+\\\"),url(\\\"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iOCIgaGVpZ2h0PSI4IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxwYXRoIGZpbGw9IiMwMDAiIGQ9Ik0wIDBoOHY4SDB6IiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGZpbGwtb3BhY2l0eT0iLjYiLz48L3N2Zz4=\\\")}.cwc-input-datalist[dir=rtl]{font-family:inherit}\\@-webkit-keyframes activate{0%{background-size:0 3px}to{background-size:100% 3px}}\\@keyframes activate{0%{background-size:0 3px}to{background-size:100% 3px}}\\@-webkit-keyframes deactivate{0%{background-size:100% 3px}to{background-size:0 3px}}\\@keyframes deactivate{0%{background-size:100% 3px}to{background-size:0 3px}}.cwc-overlay{position:fixed;z-index:999;background-image:linear-gradient(180deg,#3fa9f5,#3fa9f5 3px,#fff 0,#fff);border-radius:3px;-webkit-box-shadow:0 8px 13px rgba(0,0,0,.3);box-shadow:0 8px 13px rgba(0,0,0,.3);-webkit-box-sizing:border-box;box-sizing:border-box;overflow:auto;opacity:1;-webkit-transform-origin:top;transform-origin:top;max-height:315px;padding-top:3px}.cwc-overlay.hidden{opacity:0;-webkit-animation-name:opacityrev,bgheightrev;animation-name:opacityrev,bgheightrev}.cwc-overlay.hidden,.cwc-overlay:not(.hidden){-webkit-animation-duration:.4s;animation-duration:.4s}.cwc-overlay:not(.hidden){-webkit-animation-name:bgheight,opacity;animation-name:bgheight,opacity}\\@-webkit-keyframes opacity{0%{opacity:0}to{opacity:1}}\\@keyframes opacity{0%{opacity:0}to{opacity:1}}\\@-webkit-keyframes opacityrev{0%{opacity:1}to{opacity:0}}\\@keyframes opacityrev{0%{opacity:1}to{opacity:0}}\\@-webkit-keyframes bgheight{0%{-webkit-transform:scaleY(0);transform:scaleY(0)}to{-webkit-transform:scaleY(1);transform:scaleY(1)}}\\@keyframes bgheight{0%{-webkit-transform:scaleY(0);transform:scaleY(0)}to{-webkit-transform:scaleY(1);transform:scaleY(1)}}\\@-webkit-keyframes bgheightrev{0%{-webkit-transform:scaleY(1);transform:scaleY(1)}to{-webkit-transform:scaleY(0);transform:scaleY(0)}}\\@keyframes bgheightrev{0%{-webkit-transform:scaleY(1);transform:scaleY(1)}to{-webkit-transform:scaleY(0);transform:scaleY(0)}}.cwc-overlay.np,.cwc-overlay.pp{-webkit-transform-origin:bottom;transform-origin:bottom;-ms-flex-item-align:end;align-self:flex-end;-webkit-box-shadow:0 -8px 13px rgba(0,0,0,.3);box-shadow:0 -8px 13px rgba(0,0,0,.3);background-image:linear-gradient(0deg,var(--cwc-color-ui-highlight,#3fa9f5),var(--cwc-color-ui-highlight,#3fa9f5) 3px,var(--cwc-color-grayscale-white,#fff) 0,var(--cwc-color-grayscale-white,#fff))}.cwc-overlay.np>slot,.cwc-overlay.pp>slot{margin-top:0;margin-bottom:3px}\";\n  }\n\n};\nexport { InputDatalist as cwc_input_datalist };","map":null,"metadata":{},"sourceType":"module"}