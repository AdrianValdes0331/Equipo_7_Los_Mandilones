{"ast":null,"code":"/**\r\n * Returns whether the element is hidden.\r\n * @param elem\r\n */\nfunction isHidden(elem) {\n  return elem.hasAttribute('hidden') || elem.hasAttribute('aria-hidden') && elem.getAttribute('aria-hidden') !== 'false' || // A quick and dirty way to check whether the element is hidden.\n  // For a more fine-grained check we could use \"window.getComputedStyle\" but we don't because of bad performance.\n  // If the element has visibility set to \"hidden\" or \"collapse\", display set to \"none\" or opacity set to \"0\" through CSS\n  // we won't be able to catch it here. We accept it due to the huge performance benefits.\n  elem.style.display === `none` || elem.style.opacity === `0` || elem.style.visibility === `hidden` || elem.style.visibility === `collapse`;\n}\n/**\r\n * Returns whether the element is disabled.\r\n * @param elem\r\n */\n\n\nfunction isDisabled(elem) {\n  return elem.hasAttribute('disabled') || elem.hasAttribute('aria-disabled') && elem.getAttribute('aria-disabled') !== 'false';\n}\n/**\r\n * Determines whether an element is focusable.\r\n * Read more here: https://stackoverflow.com/questions/1599660/which-html-elements-can-receive-focus/1600194#1600194\r\n * Or here: https://stackoverflow.com/questions/18261595/how-to-check-if-a-dom-element-is-focusable\r\n * @param elem\r\n */\n\n\nfunction isFocusable(elem) {\n  // Discard elements that are removed from the tab order.\n  if (elem.getAttribute('tabindex') === '-1' || isHidden(elem) || isDisabled(elem)) {\n    return false;\n  }\n\n  return (// At this point we know that the element can have focus (eg. won't be -1) if the tabindex attribute exists\n    elem.hasAttribute('tabindex') || // Anchor tags or area tags with a href set\n    (elem instanceof HTMLAnchorElement || elem instanceof HTMLAreaElement) && elem.hasAttribute('href') || // Form elements which are not disabled\n    elem instanceof HTMLButtonElement || elem instanceof HTMLInputElement || elem instanceof HTMLTextAreaElement || elem instanceof HTMLSelectElement || // IFrames\n    elem instanceof HTMLIFrameElement\n  );\n}\n/**\r\n * Traverses the slots of the open shadowroots and returns all children matching the query.\r\n * @param {ShadowRoot | HTMLElement} root\r\n * @param skipNode\r\n * @param isMatch\r\n * @param {number} maxDepth\r\n * @param {number} depth\r\n * @returns {HTMLElement[]}\r\n */\n\n\nfunction queryShadowRoot(root, skipNode, isMatch, maxDepth = 20, depth = 0) {\n  let matches = []; // If the depth is above the max depth, abort the searching here.\n\n  if (depth >= maxDepth) {\n    return matches;\n  } // Traverses a slot element\n\n\n  const traverseSlot = slot => {\n    // Only check nodes that are of the type Node.ELEMENT_NODE\n    // Read more here https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType\n    const assignedNodes = slot.assignedNodes().filter(node => node.nodeType === 1);\n\n    if (assignedNodes.length > 0) {\n      return queryShadowRoot(assignedNodes[0].parentElement, skipNode, isMatch, maxDepth, depth + 1);\n    }\n\n    return [];\n  }; // Go through each child and continue the traversing if necessary\n  // Even though the typing says that children can't be undefined, Edge 15 sometimes gives an undefined value.\n  // Therefore we fallback to an empty array if it is undefined.\n\n\n  const children = Array.from(root.children || []);\n\n  for (const child of children) {\n    // Check if the node and its descendants should be skipped\n    if (skipNode(child)) {\n      continue;\n    } // If the child matches we always add it\n\n\n    if (isMatch(child)) {\n      matches.push(child);\n    }\n\n    if (child.shadowRoot != null) {\n      matches.push(...queryShadowRoot(child.shadowRoot, skipNode, isMatch, maxDepth, depth + 1));\n    } else if (child.tagName === 'SLOT') {\n      matches.push(...traverseSlot(child));\n    } else {\n      matches.push(...queryShadowRoot(child, skipNode, isMatch, maxDepth, depth + 1));\n    }\n  }\n\n  return matches;\n}\n\nconst tuple = (...args) => args;\n\nexport { isDisabled as a, isFocusable as b, isHidden as i, queryShadowRoot as q, tuple as t };","map":null,"metadata":{},"sourceType":"module"}