{"ast":null,"code":"import _asyncToGenerator from \"D:/Equipo_7_Los_Mandilones/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { r as registerInstance, c as createEvent, h, H as Host, g as getElement } from './core-85189c77.js';\nimport { i as initBasics, d as destroyBasics } from './commonComponentFeatures-b771e888.js';\nconst Overlay = class {\n  constructor(hostRef) {\n    registerInstance(this, hostRef);\n    this.selectMaxHeight = 500;\n    this.changed = false;\n    this.hidden = true;\n    this.layerStyle = {};\n    this.orientation = 'nn';\n    /**\n     * The design version of the framework\n     */\n\n    this.designVersion = null;\n    /**\n     * Shows and hides the overlay\n     */\n\n    this.show = false;\n    /**\n     * disables overlay toggling on target element click\n     */\n\n    this.noToggle = false;\n    /**\n     * disables the overlay funcitonality\n     */\n\n    this.disabled = false;\n    /**\n     * Specify whether component should render from right to left\n     */\n\n    this.variant = 'select';\n    /**\n     * Specify the width of the layer in CSS units\n     */\n\n    this.width = '300px';\n    /**\n     * Specify the minWidth of the layer in CSS units\n     */\n\n    this.minWidth = '250px';\n    /**\n     * Specify the height of the layer in CSS units\n     */\n\n    this.height = '220px';\n    /**\n     * Specify whether component should render from right to left\n     */\n\n    this.rtl = false;\n    /**\n     * Specify whether component should render as block or inline element\n     */\n\n    this.block = false; // this function toggles the overlay state\n\n    this.toggleOverlay = e => {\n      if (!this.disabled && !this.noToggle) {\n        if (this.hidden) {\n          return this.showOverlay();\n        }\n\n        return this.hideOverlay(e);\n      }\n    }; // this funciton shows the overlay\n\n\n    this.showOverlay = () => {\n      setTimeout(() => {\n        document.addEventListener('scroll', this.hideOverlay, true);\n        document.addEventListener('cwcScroll', this.hideOverlay, true);\n        window.addEventListener('resize', this.hideOverlay);\n        document.addEventListener('click', this.hideOverlay);\n      });\n      this.positionOverlay();\n      const pointerEvents = {\n        pointerEvents: 'all'\n      };\n      this.layerStyle = Object.assign(Object.assign({}, this.layerStyle), pointerEvents);\n      this.hidden = false;\n      this.changed = true;\n      this.showEvent.emit(true);\n    }; // this function hides the overlay\n\n\n    this.hideOverlay = e => {\n      // determine if the click is within the content slot that's within the overlay\n      const path = e.composedPath(); // sometimes we send a fake event without composed path when we hide the overlay by prop\n      // therefore we force the \"clickoutside\" by just saying it was outside\n\n      const isWithin = path ? this.isWithin(this.layer, path) : false;\n\n      if (!isWithin) {\n        document.removeEventListener('scroll', this.hideOverlay, true);\n        document.removeEventListener('cwcScroll', this.hideOverlay, true);\n        window.removeEventListener('resize', this.hideOverlay);\n        document.removeEventListener('click', this.hideOverlay);\n        const pointerEvents = {\n          pointerEvents: 'none'\n        };\n        this.layerStyle = Object.assign(Object.assign({}, this.layerStyle), pointerEvents);\n        this.hidden = true;\n        this.changed = true;\n        this.showEvent.emit(false);\n      }\n    };\n\n    this.positionOverlay = () => {\n      // find position on screen\n      const elementDimensions = this.targetElement.getBoundingClientRect(); // get overlay dimensions\n\n      const layerDimensions = this.layer.getBoundingClientRect(); // get height of the layer or use the height prop\n\n      const numHeight = this.height === 'auto' || this.height === '' || this.height === null ? this.layer.clientHeight : Number(this.height.replace(new RegExp(/(px|rem|em|%)/, 'gi'), '')); // Verify that the layer height is not less than the height prop\n\n      if (layerDimensions.height < numHeight) {\n        layerDimensions.height = numHeight;\n      } // get window width and height\n\n\n      const windowDimensions = {\n        width: document.documentElement.clientWidth,\n        height: document.documentElement.clientHeight\n      }; // define base overlay style\n\n      const minWidth = this.width === 'auto' && this.block ? this.targetElement.getBoundingClientRect().width + 'px' : this.minWidth;\n      const layerStyle = {\n        width: this.layerStyle.width,\n        height: layerDimensions.height + 'px',\n        left: '',\n        top: '',\n        pointerEvents: 'all',\n        minWidth\n      };\n      let caseString;\n      let flow;\n      let lateralOverflow;\n      let verticalOverflow;\n      /*\n      EXPLANATION OF NOMENCLATURE\n               When organizing the direction that the overlay has to go\n      the class names were chosen around the positive/negative orientation for each axis\n      therefore, a class name of 'pp' means that the overlay is flowing\n      positively horizontally (to the start) and positively vertically (upwards).\n      This also means that a class name of 'nn' determines that\n      the overlay should open negatively horizontally (to the end) and negatively vertically (downwards).\n               All calsses are build using this logic.\n      */\n\n      if (this.direction) {\n        flow = 'ltr';\n        const directionArray = this.direction.split('');\n        caseString = (directionArray[1] === 'w' ? 'p' : 'n') + (directionArray[0] === 'n' ? 'p' : 'n');\n      } else {\n        if (!this.rtl) {\n          // calculate if overflows\n          lateralOverflow = elementDimensions.left + layerDimensions.width - windowDimensions.width;\n          verticalOverflow = elementDimensions.top + layerDimensions.height - windowDimensions.height; // define the overflow scenario for a particular class and the positioning switch\n          // display overlay downwards when window heigh is smaller than the overlay\n\n          caseString = windowDimensions.height < layerDimensions.height ? (lateralOverflow > 0 ? 'p' : 'n') + 'n' : (lateralOverflow > 0 ? 'p' : 'n') + (verticalOverflow > 0 ? 'p' : 'n'); // if (windowDimensions.height < layerDimensions.height) {\n          //   caseString = (lateralOverflow > 0 ? 'p' : 'n') + 'n';\n          // } else {\n          //   caseString = (lateralOverflow > 0 ? 'p' : 'n') + (verticalOverflow > 0 ? 'p' : 'n');\n          // }\n\n          flow = 'ltr';\n        } else {\n          // calculate if overflows\n          lateralOverflow = elementDimensions.right - layerDimensions.width;\n          verticalOverflow = elementDimensions.top + layerDimensions.height - windowDimensions.height; // define the overflow scenario for a particular class and the positioning switch\n          // display overlay downwards when window heigh is smaller than the overlay\n\n          caseString = windowDimensions.height < layerDimensions.height ? (lateralOverflow < 0 ? 'p' : 'n') + 'n' : (lateralOverflow < 0 ? 'p' : 'n') + (verticalOverflow > 0 ? 'p' : 'n'); // if (windowDimensions.height < layerDimensions.height) {\n          //   caseString = (lateralOverflow < 0 ? 'p' : 'n') + 'n';\n          // } else {\n          //   caseString = (lateralOverflow < 0 ? 'p' : 'n') + (verticalOverflow > 0 ? 'p' : 'n');\n          // }\n\n          flow = 'rtl';\n        }\n      } // get the top left values with the orientation string\n\n\n      const topleft = this.getOrientation(`${flow}_${caseString}`, elementDimensions, layerDimensions); // assign the new layer style\n\n      this.layerStyle = Object.assign(Object.assign({}, layerStyle), topleft); // assign the orientation for custom orientation classes\n\n      this.orientation = caseString;\n    };\n\n    this.setLayerStyle = layerStyles => {\n      this.layerStyle = Object.assign({\n        width: this.width,\n        height: this.height\n      }, layerStyles);\n    };\n\n    this.onSlotChange = () => {\n      const pointerEvents = this.hidden ? 'none' : 'all';\n      this.layerStyle = {\n        pointerEvents\n      };\n      this.setLayerStyle({\n        pointerEvents\n      }); // Correct dimensions for variant select\n\n      if (this.variant === 'select') {\n        setTimeout(() => {\n          this.correctLayerDimensionsOnSelect(pointerEvents);\n        }, 100);\n      }\n    };\n\n    this.showEvent = createEvent(this, \"cwcShow\", 7);\n  }\n\n  handleShow(newValue, oldValue) {\n    if (newValue !== oldValue) {\n      if (this.show) {\n        this.showOverlay();\n      } else {\n        this.hideOverlay({\n          target: this.targetElement,\n\n          composedPath() {\n            return false;\n          }\n\n        });\n      }\n    }\n  }\n\n  setWidth(newValue, oldValue) {\n    if (oldValue !== newValue) {\n      this.width = newValue;\n      this.setLayerStyle({\n        pointerEvents: 'none'\n      });\n    }\n  }\n\n  setHeight(newValue, oldValue) {\n    if (oldValue !== newValue) {\n      this.height = newValue;\n      this.setLayerStyle({\n        pointerEvents: 'none'\n      });\n    }\n  }\n  /**\n   * Method to toggle the overlay state programatically.\n   */\n\n\n  toggle(e) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      _this.toggleOverlay(e);\n    })();\n  }\n  /**\n   * Method to determine if the overlay is shown at a specific moment.\n   */\n\n\n  isShown() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      return !_this2.hidden;\n    })();\n  } // this function determines if an element is within another\n\n\n  isWithin(parent, path) {\n    for (const element of path) {\n      if (parent === element) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  getOrientation(key, elementDimensions, layerDimensions) {\n    const formulas = new Map();\n    formulas.set('ltr_pn', {\n      left: elementDimensions.left + elementDimensions.width - layerDimensions.width + 'px',\n      top: elementDimensions.top + elementDimensions.height + 'px'\n    });\n    formulas.set('ltr_np', {\n      left: elementDimensions.left + 'px',\n      top: elementDimensions.top - layerDimensions.height + 'px'\n    });\n    formulas.set('ltr_pp', {\n      left: elementDimensions.left + elementDimensions.width - layerDimensions.width + 'px',\n      top: elementDimensions.top - layerDimensions.height + 'px'\n    });\n    formulas.set('ltr_nn', {\n      left: elementDimensions.left + 'px',\n      top: elementDimensions.top + elementDimensions.height + 'px'\n    });\n    formulas.set('rtl_pn', {\n      left: elementDimensions.left + 'px',\n      top: elementDimensions.top + elementDimensions.height + 'px'\n    });\n    formulas.set('rtl_np', {\n      left: elementDimensions.left + elementDimensions.width - layerDimensions.width + 'px',\n      top: elementDimensions.top - layerDimensions.height + 'px'\n    });\n    formulas.set('rtl_pp', {\n      left: elementDimensions.left + 'px',\n      top: elementDimensions.top - layerDimensions.height + 'px'\n    });\n    formulas.set('rtl_nn', {\n      left: elementDimensions.left + elementDimensions.width - layerDimensions.width + 'px',\n      top: elementDimensions.top + elementDimensions.height + 'px'\n    });\n    return formulas.get(key);\n  }\n\n  handleKeyDown(event) {\n    if (event.key === 'Escape') {\n      this.hideOverlay({\n        target: this.targetElement,\n\n        composedPath() {\n          return false;\n        }\n\n      });\n    }\n  }\n\n  componentWillLoad() {\n    this.setLayerStyle({\n      pointerEvents: 'none'\n    });\n    initBasics(this);\n  }\n\n  componentDidLoad() {\n    if (this.show) {\n      this.showOverlay();\n    }\n\n    this.layer.querySelector('slot[name=\"content\"]').addEventListener('slotchange', this.onSlotChange);\n  }\n\n  disconnectedCallback() {\n    destroyBasics(this);\n  }\n  /**\n   * Correct overlay dimensions\n   * When the component is on its max height, define this height to the component\n   * to prevent hiding scrollbar\n   */\n\n\n  correctLayerDimensionsOnSelect(pointerEvents) {\n    const layerDimensions = this.layer.getBoundingClientRect();\n\n    if (layerDimensions.height === this.selectMaxHeight) {\n      const correctedDimensions = {\n        pointerEvents,\n        height: layerDimensions.height + 'px'\n      };\n      this.setLayerStyle(correctedDimensions);\n    }\n  }\n\n  render() {\n    return h(Host, {\n      class: `${this.designVersion} ${this.block && 'block'}`\n    }, h(\"div\", {\n      ref: el => this.targetElement = el,\n      class: 'cwc-overlay__target' + (this.disabled ? ' disabled' : ''),\n      role: \"button\",\n      onClick: this.toggleOverlay,\n      style: {\n        display: this.block ? 'block' : 'inline-block'\n      }\n    }, h(\"slot\", {\n      name: \"target\"\n    })), h(\"div\", {\n      ref: el => this.layer = el,\n      class: `cwc-overlay ${this.designVersion} ${this.variant} ${this.orientation} ${this.hidden ? 'hidden' : 'show'} ${!this.changed && 'unchanged'}`,\n      style: this.layerStyle,\n      role: \"dialog\",\n      \"aria-label\": this.ariaLabel,\n      \"aria-modal\": \"true\"\n    }, h(\"slot\", {\n      name: \"content\"\n    })));\n  }\n\n  get host() {\n    return getElement(this);\n  }\n\n  static get watchers() {\n    return {\n      \"show\": [\"handleShow\"],\n      \"width\": [\"setWidth\"],\n      \"height\": [\"setHeight\"]\n    };\n  }\n\n  static get style() {\n    return \"*{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}:host{display:inline-block}:host(.block),:host(.block) .cwc-overlay__target slot{display:block}.cwc-overlay{display:-ms-flexbox;display:flex;position:fixed;z-index:999}.cwc-overlay__target{display:inline-block}.cwc-overlay__target.disabled{cursor:not-allowed;pointer-events:none!important}.cwc-overlay__target>slot{display:inline-block}.cwc-overlay.select{width:100%;height:100%;background-image:linear-gradient(180deg,var(--cwc-color-ui-highlight,#3fa9f5),var(--cwc-color-ui-highlight,#3fa9f5) 3px,var(--cwc-color-grayscale-white,#fff) 0,var(--cwc-color-grayscale-white,#fff));border-radius:3px;-webkit-box-shadow:0 8px 13px rgba(0,0,0,.3);box-shadow:0 8px 13px rgba(0,0,0,.3);display:-ms-flexbox;display:flex;-ms-flex-direction:column;flex-direction:column;min-width:40px;-webkit-box-sizing:border-box;box-sizing:border-box;overflow:hidden;opacity:1;max-height:500px;-webkit-transform-origin:top;transform-origin:top}.cwc-overlay.select>slot{display:block;width:100%;height:calc(100% - 3px);margin-top:3px;opacity:1;overflow:hidden}.cwc-overlay.hidden{opacity:0}.cwc-overlay.hidden:not(.unchanged){-webkit-animation-name:opacityrev,bgheightrev;animation-name:opacityrev,bgheightrev;-webkit-animation-duration:.4s;animation-duration:.4s}.cwc-overlay.show{opacity:1}.cwc-overlay.show:not(.unchanged){-webkit-animation-name:bgheight,opacity;animation-name:bgheight,opacity;-webkit-animation-duration:.4s;animation-duration:.4s}\\@-webkit-keyframes opacity{0%{opacity:0}to{opacity:1}}\\@keyframes opacity{0%{opacity:0}to{opacity:1}}\\@-webkit-keyframes opacityrev{0%{opacity:1}to{opacity:0}}\\@keyframes opacityrev{0%{opacity:1}to{opacity:0}}\\@-webkit-keyframes bgheight{0%{-webkit-transform:scaleY(0);transform:scaleY(0)}to{-webkit-transform:scaleY(1);transform:scaleY(1)}}\\@keyframes bgheight{0%{-webkit-transform:scaleY(0);transform:scaleY(0)}to{-webkit-transform:scaleY(1);transform:scaleY(1)}}\\@-webkit-keyframes bgheightrev{0%{-webkit-transform:scaleY(1);transform:scaleY(1)}to{-webkit-transform:scaleY(0);transform:scaleY(0)}}\\@keyframes bgheightrev{0%{-webkit-transform:scaleY(1);transform:scaleY(1)}to{-webkit-transform:scaleY(0);transform:scaleY(0)}}.cwc-overlay.np,.cwc-overlay.pp{-webkit-transform-origin:bottom;transform-origin:bottom;-ms-flex-item-align:end;align-self:flex-end;-webkit-box-shadow:0 -8px 13px rgba(0,0,0,.3);box-shadow:0 -8px 13px rgba(0,0,0,.3);background-image:linear-gradient(0deg,var(--cwc-color-ui-highlight,#3fa9f5),var(--cwc-color-ui-highlight,#3fa9f5) 3px,var(--cwc-color-grayscale-white,#fff) 0,var(--cwc-color-grayscale-white,#fff))}.cwc-overlay.np>slot,.cwc-overlay.pp>slot{margin-top:0;margin-bottom:3px}.popover{width:100%;height:100%;display:-ms-flexbox;display:flex;-ms-flex-direction:column;flex-direction:column;border-radius:0;-webkit-box-sizing:border-box;box-sizing:border-box;overflow:hidden;-webkit-filter:drop-shadow(0 8px 13px rgba(0,0,0,.3));filter:drop-shadow(0 8px 13px rgba(0,0,0,.3))}[dir=ltr] .popover slot{left:0}[dir=ltr] .popover slot,[dir=rtl] .popover slot{right:0}[dir=rtl] .popover slot{left:0}.popover slot{display:block;position:absolute;top:8px;inset-inline-start:0;inset-inline-end:0;bottom:0;z-index:1}[dir=ltr] .popover:before{border-left:8px solid transparent}[dir=ltr] .popover:before,[dir=rtl] .popover:before{border-right:8px solid transparent}[dir=rtl] .popover:before{border-left:8px solid transparent}[dir=ltr] .popover:before{margin-left:1rem}[dir=rtl] .popover:before{margin-right:1rem}.popover:before{content:\\\" \\\";display:block;width:0;height:0;-webkit-border-start:8px solid transparent;border-inline-start:8px solid transparent;-webkit-border-end:8px solid transparent;border-inline-end:8px solid transparent;border-bottom:8px solid var(--cwc-overlay-popover-border-color,var(--cwc-color-grayscale-white,#fff));-webkit-margin-start:1rem;margin-inline-start:1rem}.popover:after{content:\\\" \\\";display:block;background-color:var(--cwc-overlay-popover-background-color,var(--cwc-color-grayscale-white,#fff));width:100%;height:calc(100% - 8px)}.popover.hidden{opacity:0;pointer-events:none}.popover.show{opacity:1;pointer-events:all}[dir=ltr] .popover.pn:before,[dir=ltr] .popover.pp:before{margin-left:auto}[dir=rtl] .popover.pn:before,[dir=rtl] .popover.pp:before{margin-right:auto}[dir=ltr] .popover.pn:before,[dir=ltr] .popover.pp:before{margin-right:1rem}[dir=rtl] .popover.pn:before,[dir=rtl] .popover.pp:before{margin-left:1rem}.popover.pn:before,.popover.pp:before{-webkit-margin-start:auto;margin-inline-start:auto;-webkit-margin-end:1rem;margin-inline-end:1rem}.popover.np,.popover.pp{-ms-flex-item-align:end;align-self:flex-end;-ms-flex-flow:column-reverse;flex-flow:column-reverse;background-image:none}.popover.np slot,.popover.pp slot{top:0;bottom:8px}.popover.np:before,.popover.pp:before{-webkit-transform:scale(-1);transform:scale(-1)}\\@media (max-width:767px){[dir=ltr] .cwc-overlay.popover,[dir=ltr] .cwc-overlay.select{left:0!important}[dir=rtl] .cwc-overlay.popover,[dir=rtl] .cwc-overlay.select{right:0!important}.cwc-overlay.popover,.cwc-overlay.select{top:0!important;inset-inline-start:0!important;width:100%!important;height:100vh!important;max-height:100vh!important;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;background-color:var(--cwc-overlay-popover-max-background-color,var(--cwc-color-ui-primary-darkest-alpha-eighty,rgba(0,27,58,.8)));pointer-events:none!important}.cwc-overlay.popover>slot,.cwc-overlay.select>slot{width:calc(100% - 64px);max-height:calc(100vh - 64px);min-height:350px;min-height:10px;-ms-flex-item-align:center;align-self:center;pointer-events:all;height:auto;background-image:linear-gradient(180deg,var(--cwc-color-ui-highlight,#3fa9f5),var(--cwc-color-ui-highlight,#3fa9f5) 3px,var(--cwc-color-grayscale-white,#fff) 0,var(--cwc-color-grayscale-white,#fff))}.cwc-overlay.popover.hidden,.cwc-overlay.select.hidden{background-color:transparent}.cwc-overlay.popover.hidden>slot,.cwc-overlay.select.hidden>slot{pointer-events:none}.cwc-overlay.popover.nn,.cwc-overlay.popover.np,.cwc-overlay.popover.pn,.cwc-overlay.popover.pp,.cwc-overlay.select.nn,.cwc-overlay.select.np,.cwc-overlay.select.pn,.cwc-overlay.select.pp{background-image:none}.cwc-overlay.popover slot,.cwc-overlay.select slot{margin-bottom:0;overflow:auto;position:relative}.cwc-overlay.popover>slot{background-image:none;background-color:var(--cwc-overlay-popover-max-slot-background-color,var(--cwc-color-grayscale-white,#fff))}.cwc-overlay.popover:after,.cwc-overlay.popover:before{display:none}}\";\n  }\n\n};\nconst SelectOption = class {\n  constructor(hostRef) {\n    registerInstance(this, hostRef);\n    /**\n     * The design version of the framework\n     */\n\n    this.designVersion = null;\n    /**\n     * Enables debug logging via console.info\n     */\n\n    this.debug = false;\n    /**\n     * Allows unselection of single option\n     */\n\n    this.allowUnselection = false;\n    /**\n     * If set to true, disables emitting event for current action iteration\n     */\n\n    this.disableEmit = false;\n    /**\n     * Represent if option selected by Prop()\n     */\n\n    this.selectedByProp = true;\n    /**\n     * Sets option as selected\n     */\n\n    this.selected = false;\n    /**\n     * Sets option as focused\n     */\n\n    this.focused = false;\n    /**\n     * Defines if the option is right to left\n     */\n\n    this.rtl = false;\n    /**\n     * Hides option - used in filtered option list\n     */\n\n    this.hidden = false;\n    /**\n     * Defines if the option is multiple (display checkbox)\n     */\n\n    this.multiple = false;\n    this.optionSelectedEvent = createEvent(this, \"cwcSelectOptionSelected\", 7);\n  }\n\n  changeSelected(newValue, oldValue) {\n    this.debug && console.info(`selected prop (value: `, this.value, `, selectedByProp: ${this.selectedByProp}, disableEmit: ${this.disableEmit}) changed from `, oldValue, ` to `, newValue);\n    this.onSelectedPropChange();\n  }\n  /**\n   * Select option from outside of the component\n   */\n\n\n  selectOption(disableEmit = false) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      if (disableEmit) {\n        _this3.disableEmit = disableEmit;\n      }\n\n      _this3.selected = true;\n    })();\n  }\n  /**\n   * Unselect option from outside of the component\n   */\n\n\n  unselectOption(disableEmit = false) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      if (disableEmit) {\n        _this4.disableEmit = disableEmit;\n      }\n\n      _this4.selected = false;\n    })();\n  }\n  /**\n   * Hide option in the list - used in options filter\n   */\n\n\n  hideOption() {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      _this5.hidden = true;\n    })();\n  }\n  /**\n   * Show option in the list - used in options filter\n   */\n\n\n  showOption() {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      _this6.hidden = false;\n    })();\n  }\n  /**\n   * Highlight search characters - used in search filter\n   */\n\n\n  highlightText(searchQuery) {\n    var _this7 = this;\n\n    return _asyncToGenerator(function* () {\n      // Clear highlights\n      _this7.host.innerHTML = _this7.host.innerHTML.replace(new RegExp('<strong>', 'ig'), '').replace(new RegExp('</strong>', 'ig'), ''); // if search string is null or empty then return\n\n      if (!searchQuery) return; // Match the characters to the search query and highlight them\n\n      const originalString = _this7.host.innerHTML;\n      const index = originalString.search(new RegExp(searchQuery, 'ig')); // If string has been found highlight it in bold\n\n      if (index > -1) {\n        _this7.host.innerHTML = originalString.substring(0, index) + '<strong>' + originalString.substring(index, index + searchQuery.length) + '</strong>' + originalString.substring(index + searchQuery.length);\n      }\n    })();\n  }\n  /**\n   * Set option as multiple\n   */\n\n\n  setOptionAsMultiple() {\n    var _this8 = this;\n\n    return _asyncToGenerator(function* () {\n      _this8.multiple = true;\n\n      if (_this8.selected) {\n        _this8.setCheckboxChecked(true);\n      }\n    })();\n  }\n  /**\n   * Set option as simple\n   */\n\n\n  setOptionAsSimple() {\n    var _this9 = this;\n\n    return _asyncToGenerator(function* () {\n      _this9.multiple = false;\n    })();\n  }\n  /**\n   * Lifecycle hook - componentWillLoad\n   */\n\n\n  componentWillLoad() {\n    if (this.host) {\n      this.multiple = this.host.parentElement['multiple'] || false;\n      this.rtl = this.host.parentElement['rtl'] || false;\n      this.allowUnselection = this.host.parentElement['allowUnselection'] || false;\n    }\n\n    initBasics(this);\n  }\n  /**\n   * Lifecycle hook - componentDidLoad\n   */\n\n\n  componentDidLoad() {\n    if (this.selected && this.multiple) {\n      this.setCheckboxChecked(this.selected);\n    }\n\n    this.parentElement = this.host.parentElement;\n    this.parentElement && this.parentElement.registerOption && this.parentElement.registerOption(this.host);\n  }\n\n  disconnectedCallback() {\n    this.selected = false;\n    this.parentElement && this.parentElement.unregisterOption && this.parentElement.unregisterOption(this.host);\n    destroyBasics(this);\n  }\n\n  onSelectedPropChange() {\n    // In case of multi option, check the checkbox\n    if (this.multiple) {\n      this.setCheckboxChecked(this.selected);\n    } // Emit event to parent component if it is allowed by disableEmit and is selected\n\n\n    if (this.disableEmit === false || this.selectedByProp === false) {\n      this.emitSelectedEvent();\n    }\n\n    this.disableEmit = false;\n  }\n\n  emitSelectedEvent() {\n    const emitData = {\n      name: this.host.innerText,\n      value: this.value,\n      selected: this.selected,\n      selectedByProp: this.selectedByProp\n    };\n    this.debug && console.info('emitting optionSelectedEvent', emitData);\n    this.optionSelectedEvent.emit(emitData);\n    this.selectedByProp = true;\n  }\n\n  onOptionClick() {\n    const isDisabledOption = this.disabled && this.multiple;\n    this.selectedByProp = false;\n\n    if (isDisabledOption) {\n      this.debug && console.info(`option `, this.value, ` is disabled, click has no effect`);\n      return;\n    }\n\n    if (!this.multiple && !this.allowUnselection && this.selected) {\n      this.debug && console.info(`single option `, this.value, ` is doesn't allow unselection, set allowUnselection prop to change this`);\n      return;\n    }\n\n    this.selected = !this.selected;\n    this.debug && console.info(`option `, this.value, ` clicked, selected: ${this.selected}`);\n  }\n\n  setCheckboxChecked(isChecked) {\n    if (this.checkboxElement) {\n      this.checkboxElement.checked = isChecked;\n    }\n  }\n\n  render() {\n    let optionElement;\n\n    if (this.multiple) {\n      optionElement = h(\"cwc-checkbox\", {\n        variant: \"select-option\",\n        disabled: this.disabled,\n        onCwcChange: event => event.stopPropagation(),\n        tabindex: \"-1\",\n        ref: el => this.checkboxElement = el\n      }, h(\"slot\", null));\n    } else {\n      optionElement = h(\"span\", {\n        class: \"dropdown-option-simple\"\n      }, h(\"slot\", null));\n    }\n\n    return h(\"div\", {\n      class: `cwc-select-dd__option ${this.selected && 'selected'} ${this.multiple && 'multiple'} ${this.hidden && 'hidden'} ${this.focused && 'hover'}`,\n      onClick: this.onOptionClick.bind(this),\n      role: \"option\"\n    }, optionElement);\n  }\n\n  get host() {\n    return getElement(this);\n  }\n\n  static get watchers() {\n    return {\n      \"selected\": [\"changeSelected\"]\n    };\n  }\n\n  static get style() {\n    return \"*{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}:host{display:block}.cwc-select-dd__option{padding:.625rem 2rem;cursor:pointer;display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center}.cwc-select-dd__option.hover{background-color:var(--cwc-select-option-hover-backgorund-color,var(--cwc-color-elements-bg,#f4f6f9))}.cwc-select-dd__option.multiple{padding:0}.cwc-select-dd__option.multiple>*{width:100%;padding:0}.cwc-select-dd__option.selected .dropdown-option-simple{position:relative}.cwc-select-dd__option.selected .dropdown-option-simple:before{content:\\\"\\\";width:24px;height:16px;position:absolute;left:-26px;top:2px;background-image:url(\\\"data:image/svg+xml,%3Csvg%20width%3D%22500%22%20height%3D%22500%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%3Cpath%20fill%3D%22%233FA9F5%22%20d%3D%22M191.433%20401.667L40%20284.767l74.667-74.667%2078.166%2079.8%20190.4-191.567%2076.767%2073.5z%22%20fill-rule%3D%22evenodd%22%2F%3E%3C%2Fsvg%3E\\\");background-size:contain;background-repeat:no-repeat;background-position:50%}.cwc-select-dd__option.selected.hover{background-color:var(--cwc-select-option-selected-hover-backgorund-color,var(--cwc-color-elements-bg,#f4f6f9))}.cwc-select-dd__option.hidden{display:none}\\@media (hover:hover){.cwc-select-dd__option:hover{background-color:var(--cwc-select-option-hover-background-color,var(--cwc-color-elements-bg,#f4f6f9))}}\";\n  }\n\n};\nexport { Overlay as cwc_overlay, SelectOption as cwc_select_option };","map":null,"metadata":{},"sourceType":"module"}