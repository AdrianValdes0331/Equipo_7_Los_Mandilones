{"ast":null,"code":"import { AkitaPlugin } from '../plugin';\nimport { QueryEntity } from '../../queryEntity';\nimport { BehaviorSubject, combineLatest, Subject } from 'rxjs';\nimport { distinctUntilChanged, map, skip } from 'rxjs/operators';\nimport { isUndefined } from '../../isUndefined';\nimport { coerceArray } from '../../coerceArray';\nimport { isFunction } from '../../isFunction';\nimport { logAction } from '../../actions';\nexport const dirtyCheckDefaultParams = {\n  comparator: (head, current) => JSON.stringify(head) !== JSON.stringify(current)\n};\nexport function getNestedPath(nestedObj, path) {\n  const pathAsArray = path.split('.');\n  return pathAsArray.reduce((obj, key) => obj && obj[key] !== 'undefined' ? obj[key] : undefined, nestedObj);\n}\nexport class DirtyCheckPlugin extends AkitaPlugin {\n  constructor(query, params, _entityId) {\n    super(query);\n    this.query = query;\n    this.params = params;\n    this._entityId = _entityId;\n    this.dirty = new BehaviorSubject(false);\n    this.active = false;\n    this._reset = new Subject();\n    this.isDirty$ = this.dirty.asObservable().pipe(distinctUntilChanged());\n    this.reset$ = this._reset.asObservable();\n    this.params = { ...dirtyCheckDefaultParams,\n      ...params\n    };\n\n    if (this.params.watchProperty) {\n      const watchProp = coerceArray(this.params.watchProperty);\n\n      if (query instanceof QueryEntity && watchProp.includes('entities') && !watchProp.includes('ids')) {\n        watchProp.push('ids');\n      }\n\n      this.params.watchProperty = watchProp;\n    }\n  }\n\n  reset(params = {}) {\n    let currentValue = this.head;\n\n    if (isFunction(params.updateFn)) {\n      if (this.isEntityBased(this._entityId)) {\n        currentValue = params.updateFn(this.head, this.getQuery().getEntity(this._entityId));\n      } else {\n        currentValue = params.updateFn(this.head, this.getQuery().getValue());\n      }\n    }\n\n    logAction(`@DirtyCheck - Revert`);\n    this.updateStore(currentValue, this._entityId);\n\n    this._reset.next(true);\n  }\n\n  setHead() {\n    if (!this.active) {\n      this.activate();\n      this.active = true;\n    } else {\n      this.head = this._getHead();\n    }\n\n    this.updateDirtiness(false);\n    return this;\n  }\n\n  isDirty() {\n    return !!this.dirty.value;\n  }\n\n  hasHead() {\n    return !!this.getHead();\n  }\n\n  destroy() {\n    this.head = null;\n    this.subscription && this.subscription.unsubscribe();\n    this._reset && this._reset.complete();\n  }\n\n  isPathDirty(path) {\n    const head = this.getHead();\n    const current = this.getQuery().getValue();\n    const currentPathValue = getNestedPath(current, path);\n    const headPathValue = getNestedPath(head, path);\n    return this.params.comparator(currentPathValue, headPathValue);\n  }\n\n  getHead() {\n    return this.head;\n  }\n\n  activate() {\n    this.head = this._getHead();\n    /** if we are tracking specific properties select only the relevant ones */\n\n    const sources = this.params.watchProperty ? this.params.watchProperty.map(prop => this.query.select(state => state[prop]).pipe(map(val => ({\n      val,\n      __akitaKey: prop\n    })))) : [this.selectSource(this._entityId)];\n    this.subscription = combineLatest(sources).pipe(skip(1)).subscribe(currentState => {\n      if (isUndefined(this.head)) return;\n      /** __akitaKey is used to determine if we are tracking a specific property or a store change */\n\n      const isChange = currentState.some(state => {\n        const head = state.__akitaKey ? this.head[state.__akitaKey] : this.head;\n        const compareTo = state.__akitaKey ? state.val : state;\n        return this.params.comparator(head, compareTo);\n      });\n      this.updateDirtiness(isChange);\n    });\n  }\n\n  updateDirtiness(isDirty) {\n    this.dirty.next(isDirty);\n  }\n\n  _getHead() {\n    let head = this.getSource(this._entityId);\n\n    if (this.params.watchProperty) {\n      head = this.getWatchedValues(head);\n    }\n\n    return head;\n  }\n\n  getWatchedValues(source) {\n    return this.params.watchProperty.reduce((watched, prop) => {\n      watched[prop] = source[prop];\n      return watched;\n    }, {});\n  }\n\n} //# sourceMappingURL=dirtyCheckPlugin.js.map","map":null,"metadata":{},"sourceType":"module"}