{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/pingu/Documents/Tec/Carrera Tec sem 6/parcial_2/Cemex_Materiales/Cemex_Login_V1.0/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { r as registerInstance, c as createEvent, h, H as Host, g as getElement } from './core-85189c77.js';\nimport { i as initBasics, d as destroyBasics } from './commonComponentFeatures-b771e888.js';\nimport { f as flatpickr } from './index-a5ef71b4.js';\nvar Meridians = /*#__PURE__*/(() => {\n  (function (Meridians) {\n    Meridians[\"AM\"] = \"AM\";\n    Meridians[\"PM\"] = \"PM\";\n  })(Meridians || (Meridians = {}));\n\n  return Meridians;\n})();\nvar EReturnFormat = /*#__PURE__*/(() => {\n  (function (EReturnFormat) {\n    EReturnFormat[\"OBJECT\"] = \"object\";\n    EReturnFormat[\"STRING\"] = \"string\";\n    EReturnFormat[\"DATE\"] = \"date\";\n  })(EReturnFormat || (EReturnFormat = {}));\n\n  return EReturnFormat;\n})();\nconst InputTime = class {\n  constructor(hostRef) {\n    registerInstance(this, hostRef);\n    /**\n     * The design version of the framework\n     */\n\n    this.designVersion = null;\n    /**\n     * Input label\n     */\n\n    this.label = '';\n    /**\n     * Time picker placeholder\n     */\n\n    this.placeholder = 'Select Time';\n    /**\n     * Specify whether component should be displayed from right to left\n     */\n\n    this.rtl = false;\n    /**\n     * Status of the form field.\n     */\n\n    this.status = 'regular';\n    /**\n     * When set to true the element is required and the label is decorated with an asterisk (*)\n     */\n\n    this.required = false;\n    /**\n     * Sets the time format - 12 for 12h or 24 for 24h, default is 24h\n     */\n\n    this.format = '24h';\n    /**\n     * Sets component as disabled\n     */\n\n    this.disabled = false;\n    /**\n     * Defines minutes interval\n     */\n\n    this.minutesStep = 5;\n    /**\n     * Defines hours interval\n     */\n\n    this.hoursStep = 1;\n    /**\n     * When set to true the component doesn't render form-group wrapper\n     */\n\n    this.unwrap = false;\n    /**\n     * Specify if input label should render for mobile\n     */\n\n    this.mobile = false;\n    /**\n     * Form control hours value (always in 24h format)\n     */\n\n    this.controlHours = 0;\n    /**\n     * Form control minutes value\n     */\n\n    this.controlMinutes = 0;\n    /**\n     * Whether the meridian should be shown\n     */\n\n    this.showMeridian = false;\n    /**\n     * Return Formatted time value\n     * 'string' - in format 'HH:mm'\n     * 'object' - in format {hours: number, minutes: number}\n     * 'date' - in format Date\n     */\n\n    this.returnedFormat = EReturnFormat.OBJECT;\n    /**\n     * A time picker options object\n     */\n\n    this.timepickerOptions = {};\n    this.cwcChange = createEvent(this, \"cwcChange\", 7);\n    this.cwcBlur = createEvent(this, \"cwcBlur\", 7);\n    this.cwcFocus = createEvent(this, \"cwcFocus\", 7);\n  }\n\n  handleHoursChange(newValue, oldValue) {\n    if (newValue !== oldValue) {\n      this.initHours(newValue);\n      this.resetTimepicker();\n    }\n  }\n\n  handleMinutesChange(newValue, oldValue) {\n    if (newValue !== oldValue) {\n      this.initMinutes(newValue);\n      this.resetTimepicker();\n    }\n  }\n\n  handleTimeFormatChange(newValue, oldValue) {\n    if (newValue !== oldValue) {\n      this.timepickerOptions['time_24hr'] = newValue === '12h' ? false : true;\n      this.resetTimepicker();\n      this.initTimeFormat(newValue);\n    }\n  }\n\n  minutesStepChange() {\n    this.timepickerOptions['minuteIncrement'] = this.minutesStep;\n    this.resetTimepicker();\n  }\n\n  hoursStepChange() {\n    this.timepickerOptions['hourIncrement'] = this.hoursStep;\n    this.resetTimepicker();\n  }\n\n  onValueChanged(newValue, oldValue) {\n    if (oldValue !== newValue) {\n      this.controlValue = newValue;\n\n      if (this.inputNode) {\n        this.inputNode.value = this.formattedTimeInput;\n      }\n    }\n  }\n\n  onValueChange(newValue, oldValue) {\n    if (JSON.stringify(newValue) !== JSON.stringify(oldValue)) {\n      const time = this.normalizeValue(newValue);\n\n      if (time) {\n        this.writeValue(time.hours, time.minutes);\n      }\n    }\n  }\n  /**\n   * Normalized value of the input\n   * @param value Value to be normalized\n   * @returns Value in format {minutes: number, hours: number}\n   */\n\n\n  normalizeValue(value) {\n    if (value === null || value === undefined) {\n      return;\n    } // If value is a Date\n\n\n    if (value instanceof Date) {\n      if (!isNaN(value.getTime())) {\n        return {\n          minutes: value.getMinutes(),\n          hours: value.getHours()\n        };\n      }\n    } else if (typeof value === 'string') {\n      // If value is a 'HH:mm' string\n      if (this.validateTime(value)) {\n        return this.parseTime(value);\n      } else {\n        try {\n          // If value is a 'YYYY-MM-DD HH:mm' string\n          const time = new Date(value);\n\n          if (time && time instanceof Date && !isNaN(time.getTime())) {\n            return {\n              minutes: time.getMinutes(),\n              hours: time.getHours()\n            };\n          } else {\n            // If value is a '{hours, minutes}' string\n            const parsedTime = JSON.parse(value);\n\n            if (parsedTime.hours !== undefined && parsedTime.minutes !== undefined) {\n              return parsedTime;\n            }\n          }\n        } catch (e) {\n          return;\n        }\n      }\n    } else if (typeof value === 'object') {\n      // If value is a moment object\n      if (typeof value.format === 'function') {\n        return {\n          minutes: Number(value.format('mm')),\n          hours: Number(value.format('HH'))\n        }; // If value is an CwcInputTimeValue with 'hours' and 'minutes' properties\n      } else if (typeof value.hours !== undefined && value.minutes !== undefined) {\n        return value;\n      }\n    }\n\n    return;\n  }\n  /**\n   * Parses time from string\n   * @param value Value to be parsed\n   * @returns Returns value in format {minutes: number, hours: number}\n   */\n\n\n  parseTime(value) {\n    const time = value.split(':');\n    return {\n      hours: parseInt(time[0], 10),\n      minutes: parseInt(time[1], 10)\n    };\n  }\n  /**\n   * Set component value and emit cwcChange event. This is handy for emulating user input in automated testing tools.\n   * @param hours Hours value\n   * @param minutes Minutes value\n   */\n\n\n  writeValue(hours, minutes) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      // puts correct meridian\n      _this.meridian = hours >= 12 ? 'PM' : 'AM';\n\n      _this.initHours(hours);\n\n      _this.initMinutes(minutes);\n\n      _this.setValues();\n\n      _this.setControlValue(_this.controlHours, _this.controlMinutes);\n    })();\n  }\n  /**\n   * Opens the time picker\n   */\n\n\n  openTimepicker() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!_this2.disabled) {\n        setTimeout(() => {\n          _this2.flatPickr.open();\n        }, 0);\n      }\n    })();\n  }\n  /**\n   * Closes the time picker\n   */\n\n\n  closeTimepicker() {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      setTimeout(() => {\n        _this3.flatPickr.close();\n      });\n    })();\n  }\n  /**\n   * Creates a time picker instance using the options in this component's state\n   */\n\n\n  createTimepicker() {\n    const minTime = this.normalizeValue(this.minTime);\n    const maxTime = this.normalizeValue(this.maxTime);\n    const minTimeString = minTime ? this.formattedTime(minTime.hours, minTime.minutes) : null;\n    const maxTimeString = maxTime ? this.formattedTime(maxTime.hours, maxTime.minutes) : null;\n    /**\n     * Stores time picker configuration\n     */\n\n    const timepickerOptions = {\n      enableTime: true,\n      noCalendar: true,\n      dateFormat: 'H:i',\n      appendTo: this.host,\n      time_24hr: this.format === '24h',\n      minuteIncrement: this.minutesStep,\n      hourIncrement: this.hoursStep,\n      defaultHour: this.defaultHours,\n      defaultMinute: this.defaultMinutes,\n      disableMobile: true,\n      clickOpens: false,\n      maxDateHasTime: true,\n      minDateHasTime: true,\n      minTime: minTimeString,\n      maxTime: maxTimeString,\n      onChange: e => {\n        setTimeout(() => {\n          const theString = e[0].toString();\n          const hours = theString.substring(16, 18);\n          const minutes = theString.substring(19, 21);\n          const hoursNum = parseInt(hours, 10);\n          const minutesNum = parseInt(minutes, 10);\n          this.writeValue(hoursNum, minutesNum);\n        }, 10);\n      },\n      onOpen: () => {\n        this.cwcFocus.emit();\n\n        if (this.unwrap) {\n          this.flatPickr.calendarContainer.classList.add('unwrap');\n        }\n\n        this.backDrop.classList.add('visible');\n      },\n      onClose: () => {\n        this.cwcBlur.emit();\n\n        if (this.unwrap) {\n          this.flatPickr.calendarContainer.classList.remove('unwrap');\n        }\n\n        this.backDrop.classList.remove('visible');\n      }\n    };\n    this.timepickerOptions = timepickerOptions;\n    const fpDiv = this.inputNode.shadowRoot.querySelector('div');\n    this.flatPickr = flatpickr(fpDiv, timepickerOptions); // if hour format is 12, then let's prevent the user writing more than 12\n\n    if (this.format === '12h') {\n      const hourInput = this.flatPickr.hourElement;\n\n      const inputChange = e => {\n        const inputValue = e.target.value;\n\n        if (inputValue > 12) {\n          hourInput.value = '12';\n        }\n      };\n\n      hourInput.oninput = inputChange;\n      hourInput.onkeyup = inputChange;\n    }\n\n    this.setValues();\n  }\n  /**\n   * Destroys time picker and creates new one with new options\n   */\n\n\n  resetTimepicker() {\n    if (this.flatPickr) {\n      this.flatPickr.destroy();\n      this.createTimepicker();\n    }\n  }\n  /**\n   * Sets minimum time allowed\n   * @param hours Hours value 24h\n   * @param minutes Minutes value\n   */\n\n\n  setMinTime(hours, minutes) {\n    const time = this.formattedTime(hours, minutes);\n\n    if (this.validateTime(time)) {\n      this.timepickerOptions['minTime'] = time;\n    }\n  }\n  /**\n   * Sets maximum time allowed\n   * @param hours Hours value 24h\n   * @param minutes Minutes value\n   */\n\n\n  setMaxTime(hours, minutes) {\n    const time = this.formattedTime(hours, minutes);\n\n    if (this.validateTime(time)) {\n      this.timepickerOptions['maxTime'] = time;\n    }\n  }\n\n  handleMaxTimeChange(newValue, oldValue) {\n    if (newValue !== oldValue) {\n      this.resetTimepicker();\n    }\n  }\n\n  handleMinTimeChange(newValue, oldValue) {\n    if (newValue !== oldValue) {\n      this.resetTimepicker();\n    }\n  }\n  /**\n   * Converts CwcInputTimeValue to string time format\n   */\n\n\n  formattedTime(hours, minutes) {\n    const hoursString = hours < 10 ? `0${hours}` : `${hours}`;\n    const minutesString = minutes < 10 ? `0${minutes}` : `${minutes}`;\n    return `${hoursString}:${minutesString}`;\n  }\n  /**\n   * Lifecycle hooks\n   */\n\n\n  componentWillLoad() {\n    initBasics(this);\n    const value = this.normalizeValue(this.value);\n\n    if (value) {\n      this.initHours(value.hours);\n      this.initMinutes(value.minutes);\n    } else {\n      this.initHours(this.hours);\n      this.initMinutes(this.minutes);\n    }\n\n    const minTime = this.normalizeValue(this.minTime);\n\n    if (minTime) {\n      this.setMinTime(minTime.hours, minTime.minutes);\n    }\n\n    const maxTime = this.normalizeValue(this.maxTime);\n\n    if (maxTime) {\n      this.setMaxTime(maxTime.hours, maxTime.minutes);\n    }\n\n    this.initTimeFormat(this.format);\n    this.setValues();\n  }\n\n  componentDidLoad() {\n    if (!this.hours && !this.minutes && !this.value) {\n      this.inputNode.value = null;\n    }\n\n    this.createTimepicker();\n  }\n\n  disconnectedCallback() {\n    this.flatPickr.destroy();\n    destroyBasics(this);\n  }\n  /**\n   * Sets value of time picker\n   * @param hours Number of hours\n   * @param minutes Number of minutes\n   */\n\n\n  setControlValue(hours = this.controlHours, minutes = this.controlMinutes) {\n    this.controlValue = {\n      hours,\n      minutes\n    };\n    let respond;\n\n    switch (this.returnedFormat) {\n      case EReturnFormat.OBJECT:\n        respond = this.controlValue;\n        break;\n\n      case EReturnFormat.STRING:\n        respond = this.formattedTime(hours, minutes);\n        break;\n\n      case EReturnFormat.DATE:\n        // If the value is a full date, then we don't want to change it\n        respond = this.createNewDate(this.value, hours, minutes);\n        break;\n\n      default:\n        break;\n    }\n\n    this.cwcChange.emit(respond);\n  }\n  /**\n   * Adds leading zeroes and adjust the hours to the 12h format if set\n   */\n\n\n  get formattedHours() {\n    const hours = this.showMeridian ? this.convertTo12HourFormat(this.controlHours) : this.controlHours;\n    return this.checkLeadingZero(hours);\n  }\n\n  get formattedMinutes() {\n    return this.checkLeadingZero(this.controlMinutes);\n  }\n  /**\n   * Displays final time picker value to the UI\n   */\n\n\n  get formattedTimeInput() {\n    return `${this.formattedHours}:${this.formattedMinutes}${this.showMeridian ? ` ${this.meridian}` : ''}`;\n  }\n  /**\n   * Checks default values before parsing them to flatpickr\n   */\n\n\n  get defaultHours() {\n    if (Number.isNaN(this.hours) || !this.hours) {\n      return new Date().getHours();\n    } else {\n      return this.hours;\n    }\n  }\n\n  get defaultMinutes() {\n    if (Number.isNaN(this.minutes) || !this.minutes) {\n      return new Date().getMinutes();\n    } else {\n      return this.minutes;\n    }\n  }\n  /**\n   * Adds leading zero to numbers lower than 10\n   * Used when displaying in UI\n   */\n\n\n  checkLeadingZero(value) {\n    if (value < 10) {\n      return '0' + value;\n    }\n\n    return value.toString();\n  }\n  /**\n   * Sets initial value of the minutes\n   * Also rounds the minutes to the minutes step\n   */\n\n\n  initMinutes(minutes) {\n    // In case of bad value\n    if (Number.isNaN(minutes) || minutes === null || minutes === undefined) {\n      minutes = new Date().getMinutes();\n    } // Align minutes by the minutes step value\n\n\n    if (minutes % this.minutesStep !== 0) {\n      minutes = minutes + this.minutesStep - minutes % this.minutesStep;\n\n      if (minutes === 60 && this.hoursStep === 1) {\n        this.controlHours = this.controlHours + 1;\n      }\n    } // Validate initial value range of the minutes\n\n\n    if (minutes < 0 || minutes > 59) {\n      minutes = 0;\n    }\n\n    this.controlMinutes = minutes;\n  }\n  /**\n   * Sets initial value of the hours\n   * Also rounds the hours to the hours step\n   */\n\n\n  initHours(hours) {\n    // In case of bad value\n    if (Number.isNaN(hours) || hours === null || hours === undefined) {\n      hours = new Date().getHours();\n    } // Align hours by the hours step value\n\n\n    if (hours % this.hoursStep !== 0) {\n      hours = hours + this.hoursStep - hours % this.hoursStep;\n    } // Validate initial value range of the hours\n\n\n    if (hours > 23) {\n      hours = 23;\n    }\n\n    if (hours < 0) {\n      hours = 0;\n    }\n\n    this.controlHours = hours;\n  }\n  /**\n   * Converts hours in 24h format to the 12h format\n   * Used when displaying time in the UI\n   */\n\n\n  convertTo12HourFormat(hours) {\n    if (hours > 12) {\n      hours = hours - 12;\n    }\n\n    if (hours === 0) {\n      hours = 12;\n    }\n\n    return hours;\n  }\n  /**\n   * Define whether show time in 12h or 24h format\n   * @param timeFormat is of type CwcInputTimeFormats (12 or 24)\n   */\n\n\n  initTimeFormat(timeFormat) {\n    this.showMeridian = timeFormat === '12h';\n\n    if (this.showMeridian) {\n      this.meridian = this.controlHours < 12 ? Meridians.AM : Meridians.PM;\n    }\n  }\n  /**\n   * Validates time format\n   */\n\n\n  validateTime(time) {\n    const timeRegex = /^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/;\n    const timeWithMeridianRegex = /^([0]?[1-9]|1[0-2]):[0-5][0-9] (AM|am|PM|pm)$/;\n\n    if (timeRegex.test(time)) {\n      return true;\n    } else if (timeWithMeridianRegex.test(time)) {\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Sets hours and minutes values verified by min and max time allowed\n   */\n\n\n  setValues() {\n    if (this.controlHours !== undefined && this.controlMinutes !== undefined) {\n      const time = this.formattedTime(this.controlHours, this.controlMinutes); // verifies if the time is valid\n\n      if (this.validateTime(time)) {\n        // string time input to date\n        const minTime = this.normalizeValue(this.minTime);\n        const maxTime = this.normalizeValue(this.maxTime);\n\n        if (minTime && (this.controlHours < minTime.hours || this.controlHours === minTime.hours && this.controlMinutes < minTime.minutes)) {\n          this.controlHours = minTime.hours;\n          this.controlMinutes = minTime.minutes;\n        } else if (maxTime && (this.controlHours > maxTime.hours || this.controlHours === maxTime.hours && this.controlMinutes > maxTime.minutes)) {\n          this.controlHours = maxTime.hours;\n          this.controlMinutes = maxTime.minutes;\n        }\n      }\n\n      this.updateTimePicker();\n    }\n  }\n  /**\n   * Sets hours and minutes values in the time picker\n   */\n\n\n  updateTimePicker() {\n    if (this.flatPickr) {\n      const arrows = Array.from(this.host.getElementsByClassName('hidden-arrow'));\n      arrows.forEach(arrow => {\n        arrow.classList.remove('hidden-arrow');\n      });\n      const checkTime = this.flatPickr.input.value ? this.flatPickr.input.value.split(':').map(Number) : [];\n      const checkMinTime = this.normalizeValue(this.minTime);\n      const checkMaxTime = this.normalizeValue(this.maxTime);\n      this.flatPickr.minuteElement.value = this.formattedMinutes;\n      this.flatPickr.hourElement.value = this.formattedHours; // hide arrows if time is not valid\n\n      if (checkMinTime && checkTime[0] <= checkMinTime.hours) {\n        this.host.querySelector('.flatpickr-time .numInputWrapper .flatpickr-hour ~ span.arrowDown').classList.add('hidden-arrow');\n\n        if (checkTime[1] <= checkMinTime.minutes) {\n          this.host.querySelector('.flatpickr-time .numInputWrapper .flatpickr-minute ~ span.arrowDown').classList.add('hidden-arrow');\n        }\n      }\n\n      if (checkMaxTime && checkTime[0] >= checkMaxTime.hours) {\n        this.host.querySelector('.flatpickr-time .numInputWrapper .flatpickr-hour ~ span.arrowUp').classList.add('hidden-arrow');\n\n        if (checkTime[1] >= checkMaxTime.minutes) {\n          this.host.querySelector('.flatpickr-time .numInputWrapper .flatpickr-minute ~ span.arrowUp').classList.add('hidden-arrow');\n        }\n      }\n    }\n  }\n  /**\n   * Convert value to DateTime format with the new time\n   * @param value is of type string | Date | CwcInputTime | moment\n   * @param hours Number of hours to update to the value\n   * @param minutes Number of minutes to update to the value\n   * @returns Date object with the new time\n   */\n\n\n  createNewDate(value, hours, minutes) {\n    if (value === undefined || value === null) {\n      return new Date(0, 0, 0, hours, minutes); // If the value is a Date\n    } else if (value instanceof Date && !isNaN(value.getTime())) {\n      return new Date(value.getFullYear(), value.getMonth(), value.getDate(), hours, minutes); // If value is a moment object\n    } else if (typeof value === 'object' && typeof value.format === 'function') {\n      const year = Number(value.format('YYYY'));\n      const month = Number(value.format('MM'));\n      const day = Number(value.format('DD'));\n      return new Date(year, month - 1, day, hours, minutes);\n    } else {\n      // If the value is a string\n      const date = new Date(value);\n\n      if (!isNaN(date.getTime())) {\n        return new Date(date.getFullYear(), date.getMonth(), date.getDate(), hours, minutes);\n      } else {\n        // If the value is not a full date, then we just set the time\n        return new Date(0, 0, 0, hours, minutes);\n      }\n    }\n  }\n\n  render() {\n    return h(Host, {\n      class: `cwc-time-input ${this.designVersion} ${this.mobile ? ' cwc-time-input--mobile' : ''}`\n    }, h(\"cwc-input\", {\n      value: this.mobile ? null : this.formattedTimeInput,\n      placeholder: this.placeholder,\n      disabled: this.disabled,\n      required: this.required,\n      status: this.status,\n      statusMessage: this.statusMessage,\n      label: this.label,\n      class: \"cwc-input-time-control\",\n      unwrap: this.unwrap,\n      onCwcBlur: event => event.stopPropagation(),\n      onCwcFocus: event => event.stopPropagation(),\n      onCwcChange: event => event.stopPropagation(),\n      style: {\n        width: '100%'\n      },\n      onClick: () => this.openTimepicker(),\n      \"trailing-icon\": \"clock\",\n      ref: input => this.inputNode = input,\n      mobile: this.mobile,\n      designVersion: this.designVersion\n    }), h(\"div\", {\n      class: \"time-picker__mobile-backdrop\",\n      \"aria-hidden\": \"true\",\n      ref: backDrop => this.backDrop = backDrop,\n      onClick: () => this.closeTimepicker()\n    }));\n  }\n\n  get host() {\n    return getElement(this);\n  }\n\n  static get watchers() {\n    return {\n      \"hours\": [\"handleHoursChange\"],\n      \"minutes\": [\"handleMinutesChange\"],\n      \"format\": [\"handleTimeFormatChange\"],\n      \"minutesStep\": [\"minutesStepChange\"],\n      \"hoursStep\": [\"hoursStepChange\"],\n      \"controlValue\": [\"onValueChanged\"],\n      \"value\": [\"onValueChange\"],\n      \"maxTime\": [\"handleMaxTimeChange\"],\n      \"minTime\": [\"handleMinTimeChange\"]\n    };\n  }\n\n  static get style() {\n    return \"\\@charset \\\"UTF-8\\\";*{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.cwc-time-input{display:inline-block;position:relative;font-family:inherit}.cwc-time-input.cwc-time-input--mobile .flatpickr-calendar,.cwc-time-input.v2 .flatpickr-calendar{top:2.5rem!important}[dir=ltr] cwc-input-time .flatpickr-calendar{left:0!important}[dir=rtl] cwc-input-time .flatpickr-calendar{right:0!important}cwc-input-time .flatpickr-calendar{display:-ms-flexbox;display:flex;max-height:0;overflow:hidden;direction:ltr;position:absolute;width:100%;-webkit-box-sizing:border-box;box-sizing:border-box;-ms-touch-action:manipulation;touch-action:manipulation;background:var(--cwc-input-time-calendar-background-color,var(--cwc-color-grayscale-white,#fff));-webkit-box-shadow:0 5px 20px var(--cwc-color-grayscale-black-alpha-ten,rgba(0,0,0,.1));box-shadow:0 5px 20px var(--cwc-color-grayscale-black-alpha-ten,rgba(0,0,0,.1));border-radius:.125rem;top:3.75rem!important;inset-inline-start:0!important;background-repeat:no-repeat;background-image:var(--cwc-color-ui-highlight-gradient,url(data:image/svg+xml,%3Csvg%20width%3D%2210%22%20height%3D%2210%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%3Cpath%20fill%3D%22%233FA9F5%22%20d%3D%22M0%200h10v10H0z%22%2F%3E%3C%2Fsvg%3E));background-size:100% 3px;background-position:0 0;-webkit-transition:max-height .5s,padding .5s;transition:max-height .5s,padding .5s;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;border:none;-webkit-animation:deactivate .35s linear 1;animation:deactivate .35s linear 1;-webkit-animation-fill-mode:forwards;animation-fill-mode:forwards}cwc-input-time .flatpickr-calendar.inline,cwc-input-time .flatpickr-calendar.open{opacity:1;max-height:640px;visibility:visible}cwc-input-time .flatpickr-calendar.open{z-index:99999;-webkit-animation:activate .35s linear 1;animation:activate .35s linear 1;-webkit-transition:max-height .5s,padding .5s;transition:max-height .5s,padding .5s;max-height:254px;padding:.5rem}cwc-input-time .flatpickr-calendar:focus{outline:none}cwc-input-time .flatpickr-time{display:-ms-flexbox;display:flex;-ms-flex-pack:center;justify-content:center;-ms-flex-align:center;align-items:center;padding:1rem 0}cwc-input-time .flatpickr-time-separator{padding:0 .25rem}cwc-input-time .flatpickr-time:focus{outline:none}cwc-input-time .flatpickr-time .numInputWrapper{display:-ms-inline-grid;display:inline-grid;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;text-align:center}cwc-input-time .flatpickr-time .numInputWrapper span{cursor:pointer;-webkit-box-sizing:border-box;box-sizing:border-box}cwc-input-time .flatpickr-time .numInputWrapper span.arrowDown,cwc-input-time .flatpickr-time .numInputWrapper span.arrowUp{font-family:dls-icons!important;speak:none;font-size:1rem;line-height:.5rem;padding:.25rem 0;margin:.5rem 0;display:block;height:16px}cwc-input-time .flatpickr-time .numInputWrapper span.arrowDown:before,cwc-input-time .flatpickr-time .numInputWrapper span.arrowUp:before{color:var(--cwc-input-time-arrows-color,var(--cwc-color-links,#3fa9f5))}cwc-input-time .flatpickr-time .numInputWrapper span.arrowUp{-ms-grid-row:1;grid-row-start:1}cwc-input-time .flatpickr-time .numInputWrapper span.arrowUp:before{content:\\\"\\\"}cwc-input-time .flatpickr-time .numInputWrapper span.arrowDown{-ms-grid-row:3;grid-row-start:3}cwc-input-time .flatpickr-time .numInputWrapper span.arrowDown:before{content:\\\"\\\"}cwc-input-time .flatpickr-hour,cwc-input-time .flatpickr-minute{font-size:1rem;line-height:1rem;border-radius:3px;height:2.5rem;padding:0 1rem;border:.0625rem solid var(--cwc-input-time-numbers-border-color,var(--cwc-input-time-numbers-border-color,#adaebb));background-color:var(--cwc-input-time-numbers-background-color,var(--cwc-color-grayscale-white,#fff));font-family:inherit;-webkit-box-sizing:border-box;box-sizing:border-box;text-align:center}cwc-input-time .flatpickr-hour::-webkit-inner-spin-button,cwc-input-time .flatpickr-hour::-webkit-outer-spin-button,cwc-input-time .flatpickr-minute::-webkit-inner-spin-button,cwc-input-time .flatpickr-minute::-webkit-outer-spin-button{-webkit-appearance:none;margin:0}cwc-input-time .flatpickr-hour[type=number],cwc-input-time .flatpickr-minute[type=number]{-moz-appearance:textfield}cwc-input-time .flatpickr-hour:active,cwc-input-time .flatpickr-hour:focus,cwc-input-time .flatpickr-minute:active,cwc-input-time .flatpickr-minute:focus{outline:0 none;border-color:var(--cwc-input-time-numbers-focus-border-color,var(--cwc-color-links,#3fa9f5));background-color:var(--cwc-input-time-numbers-focus-background-color,var(--cwc-color-grayscale-white,#fff))}cwc-input-time .flatpickr-hour:disabled,cwc-input-time .flatpickr-minute:disabled{background-color:var(--cwc-input-time-numbers-disabled-background-color,var(--cwc-color-grayscale-light,#d6d6d6))}cwc-input-time .flatpickr-hour:disabled:active,cwc-input-time .flatpickr-hour:disabled:focus,cwc-input-time .flatpickr-minute:disabled:active,cwc-input-time .flatpickr-minute:disabled:focus{border-color:var(--cwc-input-time-numbers-disabled-focus-border-color,var(--cwc-color-elements-input-border,#adaebb))}cwc-input-time .flatpickr-hour:-moz-read-only,cwc-input-time .flatpickr-minute:-moz-read-only{pointer-events:none}cwc-input-time .flatpickr-hour:read-only,cwc-input-time .flatpickr-minute:read-only{pointer-events:none}cwc-input-time .flatpickr-hour::-webkit-input-placeholder,cwc-input-time .flatpickr-minute::-webkit-input-placeholder{color:var(--cwc-input-time-numbers-placeholder-color,var(--cwc-color-grayscale-medium,#666));font-size:1rem;line-height:normal!important}cwc-input-time .flatpickr-hour::-moz-placeholder,cwc-input-time .flatpickr-minute::-moz-placeholder{color:var(--cwc-input-time-numbers-placeholder-color,var(--cwc-color-grayscale-medium,#666));font-size:1rem}cwc-input-time .flatpickr-hour:-ms-input-placeholder,cwc-input-time .flatpickr-minute:-ms-input-placeholder{color:var(--cwc-input-time-numbers-placeholder-color,var(--cwc-color-grayscale-medium,#666));font-size:1rem}cwc-input-time .flatpickr-hour:-moz-placeholder,cwc-input-time .flatpickr-minute:-moz-placeholder{color:var(--cwc-input-time-numbers-placeholder-color,var(--cwc-color-grayscale-medium,#666));font-size:1rem}cwc-input-time .flatpickr-hour:-webkit-autofill:first-line,cwc-input-time .flatpickr-minute:-webkit-autofill:first-line{font-size:1rem;font-family:inherit}[dir=ltr] cwc-input-time .flatpickr-am-pm{margin-left:.375rem}[dir=rtl] cwc-input-time .flatpickr-am-pm{margin-right:.375rem}cwc-input-time .flatpickr-am-pm{-webkit-margin-start:.375rem;margin-inline-start:.375rem;cursor:pointer;width:26px;color:var(--cwc-input-time-am-pm-color,var(--cwc-color-links,#3fa9f5));font-weight:500}[dir=ltr] .time-picker__mobile-backdrop{left:0}[dir=rtl] .time-picker__mobile-backdrop{right:0}.time-picker__mobile-backdrop{background-color:transparent;display:block;width:100%;height:100%;position:fixed;z-index:998;opacity:0;pointer-events:none;-webkit-transition:opacity .25s ease;transition:opacity .25s ease;top:0;inset-inline-start:0}.time-picker__mobile-backdrop.visible{opacity:.8;pointer-events:all}\\@media (min-width:768px){.time-picker__mobile-backdrop{display:none}}\\@media (max-width:767px){.time-picker__mobile-backdrop{background-color:var(--cwc-input-time-mobile-backdrop-background-color,var(--cwc-color-grayscale-black,#000))}}[dir=rtl] cwc-input-time .flatpickr-calendar{direction:rtl}[dir=rtl] cwc-input-time .flatpickr-hour,[dir=rtl] cwc-input-time .flatpickr-minute{font-family:inherit}[dir=rtl] cwc-input-time .flatpickr-hour:-webkit-autofill:first-line,[dir=rtl] cwc-input-time .flatpickr-minute:-webkit-autofill:first-line{font-family:inherit}[dir=rtl] .cwc-time-input{font-family:inherit}\\@-webkit-keyframes activate{0%{background-size:0 3px}to{background-size:100% 3px}}\\@keyframes activate{0%{background-size:0 3px}to{background-size:100% 3px}}\\@-webkit-keyframes deactivate{0%{background-size:100% 3px}to{background-size:0 3px}}\\@keyframes deactivate{0%{background-size:100% 3px}to{background-size:0 3px}}.hidden-arrow{pointer-events:none}.hidden-arrow:before{color:var(--cwc-color-grayscale-light,#666);pointer-events:none;opacity:.1}\";\n  }\n\n};\nexport { InputTime as cwc_input_time };","map":null,"metadata":{},"sourceType":"module"}