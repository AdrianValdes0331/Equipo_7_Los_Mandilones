{"ast":null,"code":"import { r as registerInstance, c as createEvent, h, H as Host, g as getElement } from './core-85189c77.js';\nimport { i as initBasics, d as destroyBasics } from './commonComponentFeatures-b771e888.js';\nconst CwcTabs = class {\n  constructor(hostRef) {\n    registerInstance(this, hostRef);\n    /**\n     * The design version of the framework\n     */\n\n    this.designVersion = null;\n    /**\n     * The amount of tabs present\n     */\n\n    this.tabsNum = 0;\n    /**\n     * Text-direction is right-to-left\n     */\n\n    this.rtl = false;\n    /**\n     * Dropdown title\n     */\n\n    this.dropdownTitle = 'Default title';\n    /**\n     * When set, it prevents automatic tab activation on tab click\n     */\n\n    this.disableActivation = false;\n    this.listOpen = false;\n    /**\n     * Style variants can be invoked here.\n     */\n\n    this.variant = 'regular';\n    /**\n     * sets deiverse properties depending on the contents of the slot\n     */\n\n    this.onSlotChange = () => {\n      const tabs = this.host.querySelectorAll('cwc-tab');\n      this.tabsNum = tabs.length;\n      tabs[0].isSingle = tabs.length === 1;\n      this.assingIndex();\n    };\n    /**\n     * finds active tab and gets its position\n     */\n\n\n    this.findActive = () => {\n      const find = this.host.querySelector('.active');\n      const index = find.getAttribute('index');\n      this.active = index;\n    };\n    /**\n     * finds last active tab and gets its position\n     */\n\n\n    this.activeBefore = () => {\n      const find = this.host.querySelector('.active');\n      this.lastActive = find.getAttribute('index');\n    };\n    /**\n     * compares what position has active tab to last active tab\n     */\n\n\n    this.compare = () => {\n      const allTabs = this.host.querySelectorAll('cwc-tab');\n      const arr = Array.from(allTabs);\n      arr.forEach(item => {\n        item.classList.remove('class', 'anim-rtl');\n      });\n\n      if (this.active < this.lastActive) {\n        const activeEl = this.host.querySelector('.active');\n        activeEl.classList.add('anim-rtl');\n      }\n    };\n\n    this.resizeBar = () => {\n      if (!(this.tabsNum === 1) && this.selectedTab) {\n        this.slider.style.left = this.selectedTab.offsetLeft + 'px';\n        this.slider.style.width = this.selectedTab.offsetWidth + 'px';\n      }\n    };\n\n    this.tabActivatedEvent = createEvent(this, \"cwcTabActivated\", 7);\n  }\n\n  setDisabled(newValue, oldValue) {\n    if (newValue !== oldValue) {\n      this.passDisabledToChildren(newValue);\n    }\n  }\n\n  setVariant(newValue, oldValue) {\n    if (newValue !== oldValue) {\n      this.setVariantToChildren(newValue);\n    }\n  }\n  /**\n   * Catches events from tab activations via active prop (only when active is true)\n   * @param event carries the name of the clicked element\n   */\n\n\n  tabActivatedHandler(event) {\n    event.stopPropagation();\n    this.tabActivatedEvent.emit(event.detail);\n    this.headerTitle = event.target.textContent;\n    this.selectedTab = event.target;\n    this.listOpen = false;\n\n    for (let iterator = 0; iterator < this.tabsInOrder.length; iterator++) {\n      if (this.tabsInOrder.item(iterator).name !== this.selectedTab.name) {\n        this.tabsInOrder.item(iterator).active = false;\n      }\n    }\n\n    if (this.variant === 'heading') {\n      this.resizeBar();\n    }\n  }\n  /**\n   * Gets a tab [delta] items away from the point of origin; used to select the next or previous tab.\n   * @param sourceTab a tab in this tab-list\n   * @param delta an integer value\n   * @param wrap whether navigating with arrow keys wraps from start to end of the tabs and back\n   */\n\n\n  getTabByDelta(sourceTab, delta, wrap = true) {\n    const itsName = sourceTab.name;\n    let tabToReturn = null;\n    let ordinal = 0; // First, locate the starting point within the HTMLCollection object\n\n    for (let iterator = 0; iterator < this.tabsInOrder.length; iterator++) {\n      if (this.tabsInOrder.item(iterator).name === itsName) {\n        // We have the point of origin, now get the delta.\n        // First, are we wrapping around when the cursor reaches the end of a set of tabs?\n        ordinal = wrap ? // We are wrapping.\n        iterator + delta < 0 ? this.tabsInOrder.length + iterator + delta : (iterator + delta) % this.tabsInOrder.length : // No wrapping, so constrain movement to the range bounds.\n        Math.max(Math.min(iterator + delta, this.tabsInOrder.length - 1), 0); // Set the return value, and stop running this loop.\n\n        tabToReturn = this.tabsInOrder.item(ordinal);\n        break;\n      }\n    }\n\n    return tabToReturn;\n  }\n  /**\n   * Provides the standard change-of-tab work based on a click event.\n   * @param event carries the id of the clicked element\n   * Catches events from tab clicks\n   * @param event carries the name of the clicked element\n   */\n\n\n  tabClickedHandler(event) {\n    event.stopPropagation();\n\n    if (this.disableActivation) {\n      this.tabActivatedEvent.emit(event.detail);\n      return;\n    }\n\n    this.host.querySelectorAll('cwc-tab').forEach(tab => {\n      tab['active'] = tab['name'] === event.detail;\n    });\n    this.activeBefore();\n    setTimeout(this.findActive, 1);\n    setTimeout(this.compare, 2);\n  }\n\n  handleClick(event) {\n    if (this.listOpen && !this.host.contains(event.target)) {\n      this.listOpen = false;\n    }\n  }\n\n  handleKeyPresses(event) {\n    const theSourceElement = event.target; // It should be possible to tab out of the component, but trap all other key-presses.\n\n    if (event.key !== 'Tab') {\n      event.preventDefault();\n    }\n\n    switch (event.key) {\n      case 'ArrowLeft':\n        if (this.rtl) {\n          this.focusOn(this.getTabByDelta(theSourceElement, 1));\n        } else {\n          this.focusOn(this.getTabByDelta(theSourceElement, -1));\n        }\n\n        break;\n\n      case 'ArrowRight':\n        if (this.rtl) {\n          this.focusOn(this.getTabByDelta(theSourceElement, -1));\n        } else {\n          this.focusOn(this.getTabByDelta(theSourceElement, 1));\n        }\n\n        break;\n\n      case 'Tab':\n        // todo: await decision on whether we're treating tabs as part of the main document navigation flow, or a closed group of items in one component.  If it's the first, then we bubble the event up instead of looping around, so as to continue through the doc.  In the latter case, then we should only use the arrow keys to navigate within the tab-set - because the tab key should focus only on the tab-set, and not on individual tabs.\n        break;\n      // Fall through to activate for all these events\n\n      case ' ':\n      case 'Accept':\n      case 'Enter':\n      case 'Execute':\n      case 'Select':\n        if (!this.disableActivation) {\n          this.activate(event);\n        }\n\n        break;\n\n      default: // Do nowt.\n\n    }\n  }\n\n  focusOn(anElement) {\n    if (anElement === null) {\n      return;\n    }\n\n    anElement.giveFocus();\n  }\n\n  activate(event) {\n    event.preventDefault();\n    const theEventTarget = this.getTabByDelta(event.target, 0);\n    this.focusOn(theEventTarget);\n    event.target.active = true;\n    this.activeBefore();\n    setTimeout(this.findActive, 1);\n    setTimeout(this.compare, 2);\n  }\n\n  componentWillLoad() {\n    this.tabsInOrder = this.host.getElementsByTagName('cwc-tab');\n    this.setVariantToChildren(this.variant);\n    this.passDirectionToChildren();\n    this.passDisabledToChildren(this.disableActivation);\n    this.onSlotChange();\n    initBasics(this);\n  }\n\n  setVariantToChildren(variant) {\n    this.host.querySelectorAll('cwc-tab').forEach(tab => {\n      tab['variant'] = variant;\n    });\n  }\n  /**\n   * Pass direction to children elements\n   */\n\n\n  passDirectionToChildren() {\n    this.host.querySelectorAll('cwc-tab').forEach(tab => {\n      tab['rtl'] = this.rtl;\n    });\n  }\n  /**\n   * Pass disabled activation to children\n   */\n\n\n  passDisabledToChildren(disabled) {\n    this.host.querySelectorAll('cwc-tab').forEach(tab => {\n      tab['disabled'] = disabled;\n    });\n  }\n\n  componentDidRender() {\n    if (this.variant === 'heading') {\n      this.resizeBar();\n    }\n  }\n\n  componentDidLoad() {\n    // ad an event listener to check on how many tabs are there and turn into heading if there's only one\n    const slot = this.host.shadowRoot.querySelector('slot');\n    slot.addEventListener('slotchange', this.onSlotChange); // invoke the funciton also here so that it finds out if the slot has one tab (since at load there hae been no slot changes)\n\n    this.onSlotChange();\n    this.headerTitle = this.dropdownTitle;\n    this.selectedTab = this.host.querySelector('.active');\n\n    if (this.variant === 'heading') {\n      // add an event listener when window is resized to adjust slider (underline) for heading variant\n      window.addEventListener('resize', this.resizeBar);\n    }\n  }\n\n  disconnectedCallback() {\n    const slot = this.host.shadowRoot.querySelector('slot');\n\n    if (slot) {\n      slot.removeEventListener('slotchange', this.onSlotChange);\n    }\n\n    if (this.variant === 'heading') {\n      window.removeEventListener('resize', this.resizeBar);\n    }\n\n    destroyBasics(this);\n  }\n  /**\n   * assings postion index numbers to all tabs\n   */\n\n\n  assingIndex() {\n    const allTabs = this.host.querySelectorAll('cwc-tab');\n    const arr = Array.from(allTabs);\n    arr.forEach((item, index) => {\n      item.setAttribute('index', `${index}`);\n    });\n  }\n\n  render() {\n    return h(Host, {\n      role: this.tabsNum === 1 ? 'region' : 'tablist',\n      class: `${this.variant} ${this.designVersion} ${this.tabsNum === 1 && 'single-tab'}`\n    }, h(\"slot\", null), this.variant === 'heading' && h(\"div\", {\n      class: \"cwc-tabs__slider\",\n      ref: el => this.slider = el\n    }));\n  }\n\n  get host() {\n    return getElement(this);\n  }\n\n  static get watchers() {\n    return {\n      \"disableActivation\": [\"setDisabled\"],\n      \"variant\": [\"setVariant\"]\n    };\n  }\n\n  static get style() {\n    return \"*{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}:host{list-style:none;display:-ms-flexbox;display:flex;-ms-flex-wrap:nowrap;flex-wrap:nowrap;margin:0;overflow-x:auto;padding:0;width:100%}:host:after{content:\\\"\\\";border-bottom:1px solid var(--cwc-tabs-border-color,var(--cwc-color-grayscale-light,#d6d6d6));-ms-flex:1 1 auto;flex:1 1 auto}:host(.heading){-webkit-box-shadow:0 4px 2px -1px var(--cwc-color-grayscale-black-alpha-ten,rgba(0,0,0,.1));box-shadow:0 4px 2px -1px var(--cwc-color-grayscale-black-alpha-ten,rgba(0,0,0,.1));position:relative;border:none}:host(.heading):after{border:0}[dir=ltr] .cwc-tabs__slider{left:0}[dir=rtl] .cwc-tabs__slider{right:0}.cwc-tabs__slider{background:var(--cwc-tabs-slider-background-color,var(--cwc-color-ui-highlight,#3fa9f5));height:3px;position:absolute;inset-inline-start:0;top:calc(100% - 3px);-webkit-transition:left .25s ease-out;transition:left .25s ease-out}\\@media (max-width:767px){:host:after{display:none}}:host(.heading.single-tab),:host(.single-tab){-webkit-box-shadow:none;box-shadow:none}:host(.heading.single-tab):after,:host(.single-tab):after{display:none}\";\n  }\n\n};\nexport { CwcTabs as cwc_tabs };","map":null,"metadata":{},"sourceType":"module"}