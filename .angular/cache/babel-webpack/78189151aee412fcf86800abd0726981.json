{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/pingu/Documents/Tec/Carrera Tec sem 6/parcial_2/Cemex_Materiales/Cemex_Login_V1.0/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { r as registerInstance, c as createEvent, h, H as Host, g as getElement } from './core-85189c77.js';\nimport { i as initBasics, d as destroyBasics } from './commonComponentFeatures-b771e888.js';\nvar EReturnFormat = /*#__PURE__*/(() => {\n  (function (EReturnFormat) {\n    EReturnFormat[\"OBJECT\"] = \"object\";\n    EReturnFormat[\"STRING\"] = \"string\";\n    EReturnFormat[\"ANY\"] = \"any\";\n  })(EReturnFormat || (EReturnFormat = {}));\n\n  return EReturnFormat;\n})();\nconst Select = class {\n  constructor(hostRef) {\n    registerInstance(this, hostRef);\n    /**\n     * The CwcSelectOption tags nested in this component\n     */\n\n    this.allDropdownOptions = [];\n    /**\n     * The design version of the framework\n     */\n\n    this.designVersion = null;\n    /**\n     * Enables debug logging via console.info\n     */\n\n    this.debug = false;\n    /** Defines max height in px of the select dropdown */\n\n    this.dropdownMaxHeight = null;\n    /**\n     * Input label\n     */\n\n    this.label = '';\n    /**\n     * Status of the form field.\n     */\n\n    this.status = 'regular';\n    /**\n     * Defines if the options will be multiple (with checkbox)\n     */\n\n    this.multiple = false;\n    /**\n     * Allows unselection of single option\n     */\n\n    this.allowUnselection = false;\n    /**\n     * When set to true, loader will appear inside the input\n     */\n\n    this.loading = false;\n    /**\n     * When set to true, dropdown will show options filter input\n     */\n\n    this.filter = false;\n    /**\n     * Value of the filter input\n     */\n\n    this.filterValue = null;\n    /**\n     * Placeholder for options filter input\n     */\n\n    this.filterPlaceholder = 'Filter Options';\n    /**\n     * Debounce time applied on options filter input (in milliseconds)\n     */\n\n    this.filterDebounceTime = 0;\n    /**\n     * Text displayed when options filter has no results\n     */\n\n    this.filterNoResultsMessage = 'No results';\n    /**\n     * Defines whether on multiple option should show option \"Select All\"\n     */\n\n    this.selectAll = false;\n    /**\n     * Select all checkbox label\n     */\n\n    this.selectAllLabel = 'Select all';\n    /**\n     * Sets component as disabled\n     */\n\n    this.disabled = false;\n    /**\n     * Sets trailing icon of dropdown\n     */\n\n    this.trailingIcon = 'down-single';\n    /**\n     * Specify whether component should render from right to left\n     */\n\n    this.rtl = false;\n    /**\n     * When set to true the element is required and the label is decorated with an asterisk (*)\n     */\n\n    this.required = false;\n    /**\n     * When set to true the component doesn't render form-group wrapper\n     */\n\n    this.unwrap = false;\n    /**\n     * Specify if input label should render for mobile\n     */\n\n    this.mobile = false;\n    /**\n     * This property sets the appearance variation of the select.\n     */\n\n    this.variant = 'regular';\n    /**\n     * Specify the width of the layer in CSS units\n     */\n\n    this.width = 'auto';\n    /**\n     * Specify the minWidth of the layer in CSS units\n     */\n\n    this.minWidth = '100px';\n    /**\n     * Specify the height of the layer in CSS units\n     */\n\n    this.height = 'auto';\n    /**\n     * Options list of the select\n     */\n\n    this.dataList = [];\n    /**\n     * Return formatted value of the component.\n     * 'string': in format text.\n     * 'object': in format {name: string, value: any, selected: boolean}.\n     * 'any': in format original value.\n     * Can be simple or multiple\n     */\n\n    this.returnedFormat = EReturnFormat.OBJECT;\n    /**\n     * Value of the selected option(s)\n     */\n\n    this.controlValue = null;\n    /**\n     * Shows the dropdown options list\n     */\n\n    this.showDropdown = false;\n    /**\n     * Currently selected options\n     */\n\n    this.selectedOptions = [];\n    /**\n     * Defines whether the filter result is empty\n     */\n\n    this.emptyFilter = false;\n    /**\n     * Shows footer when set to true\n     * Footer is added through slot named 'footer'\n     */\n\n    this.showFooter = false;\n    /**\n     * Value displayed in dropdown input\n     */\n\n    this.labelValue = '';\n\n    this.onBlur = ev => {\n      ev.stopPropagation();\n      window.removeEventListener('keydown', this.handleKeystrokes);\n      this.cwcBlur.emit();\n    };\n\n    this.onFocus = ev => {\n      ev.stopPropagation();\n      window.addEventListener('keydown', this.handleKeystrokes);\n      this.cwcFocus.emit();\n    };\n\n    this.closeDropdown = () => {\n      if (this.showDropdown) {\n        this.showDropdown = false;\n        this.trailingIcon = 'down-single';\n        this.debug && console.info('closing dropdown');\n      }\n    };\n\n    this.openDropdown = () => {\n      if (!this.showDropdown && !this.disabled && !this.loading) {\n        this.showDropdown = true;\n        this.trailingIcon = 'up-single';\n        this.debug && console.info('opening dropdown');\n      }\n    };\n\n    this.toggleDropdown = () => {\n      if (this.showDropdown) {\n        this.closeDropdown();\n      } else {\n        this.openDropdown();\n      }\n    }; // returns all options and helpers such as Select All if present\n\n\n    this.optionsAndHelpers = () => {\n      if (this.selectAll) {\n        return [...[this.selectAllOptionEl], ...this.allDropdownOptions];\n      }\n\n      return this.allDropdownOptions;\n    }; // selects/toggles keyboard focused option\n\n\n    this.selectFocused = () => {\n      const optionsToBrowse = this.optionsAndHelpers(); // determine if there's a focused option\n\n      const focusedOption = optionsToBrowse.filter(optionEl => optionEl.focused === true)[0];\n\n      if (focusedOption) {\n        if (focusedOption.selected) {\n          focusedOption.unselectOption();\n        } else {\n          focusedOption.selectOption();\n        }\n\n        if (!this.multiple) {\n          this.closeDropdown();\n        }\n      }\n    }; // this function we use to navigate the options list with arrows up and down.\n\n\n    this.navigateList = (down = true) => {\n      // if the list is closed, let's open it\n      this.openDropdown(); // lets browse options and select all if present\n\n      const optionsToBrowse = this.optionsAndHelpers(); // determine if there's a focused option\n\n      const focusedOption = optionsToBrowse.filter(optionEl => optionEl.focused === true)[0];\n      let nextOption;\n      const resetIndex = down ? 0 : optionsToBrowse.length - 1;\n\n      if (focusedOption) {\n        // we remove the focus from ye olde option\n        focusedOption.focused = false; // we move next or rev depending on the down mode\n        // check the index of next/prev option\n\n        const nextOptionIndex = optionsToBrowse.indexOf(focusedOption) + (down ? 1 : -1);\n        nextOption = optionsToBrowse[nextOptionIndex];\n\n        if (!nextOption) {\n          // if next sibling element is null, then we are at the end/top of the list, so we reset\n          nextOption = optionsToBrowse[resetIndex];\n        }\n      } else {\n        // if tnothing's focused we start from the reset point as well\n        nextOption = optionsToBrowse[resetIndex];\n      } // we set property focused as true\n\n\n      nextOption.focused = true; // we scroll the option into view if it's not.\n\n      nextOption.scrollIntoView(false);\n    };\n\n    this.handleKeystrokes = e => {\n      // get the pressed key\n      const key = e.code; // we let tab get used normally to advance back and forth in the tabindex\n\n      if (key !== 'Tab') {\n        // if not tab, let's prevent default behavior to act upon the keystroke\n        e.preventDefault(); // get the adequate funciton for each keystroke\n\n        const keyFn = this.getKeystrokeFunction(key); // if there's a function\n\n        if (keyFn) {\n          // execute\n          keyFn(e);\n        } // add support for filtering keydown implementation here on else\n\n      }\n    };\n\n    this.cwcChange = createEvent(this, \"cwcChange\", 7);\n    this.cwcFilter = createEvent(this, \"cwcFilter\", 7);\n    this.cwcBlur = createEvent(this, \"cwcBlur\", 7);\n    this.cwcFocus = createEvent(this, \"cwcFocus\", 7);\n  }\n\n  setSelections(newValues, oldValues) {\n    if (JSON.stringify(newValues) !== JSON.stringify(oldValues)) {\n      this.checkSelectValue(newValues, false);\n    }\n  }\n\n  changeMultiple(isMultiple) {\n    if (isMultiple) {\n      this.allDropdownOptions.forEach(option => option.setOptionAsMultiple());\n    } else {\n      this.allDropdownOptions.forEach(option => {\n        option.setOptionAsSimple();\n        option.unselectOption();\n      });\n      this.selectedOptions = [];\n      this.reflectSelectedOptionsToComponent();\n    }\n  }\n\n  changeAllowUnselection(allowUnselection) {\n    this.allDropdownOptions.forEach(option => option.allowUnselection = allowUnselection);\n  }\n\n  filterValueChanged(newValue) {\n    this.filterOptions(newValue);\n  }\n\n  changeSelectAll(selectAll) {\n    if (selectAll) {\n      this.registerSelectAllOption();\n    } else {\n      this.selectAllOptionEl = undefined;\n    }\n  }\n\n  changeRtl(isRtl) {\n    this.allDropdownOptions.forEach(option => option.rtl = isRtl);\n    this.setSelectAllOptionElementDirection();\n  }\n\n  changeVariant(newVariant, oldVariant) {\n    if (newVariant !== oldVariant) {\n      this.reflectSelectedOptionsToComponent();\n    }\n  }\n\n  changedataList(newOptions, oldOptions) {\n    if (JSON.stringify(newOptions) !== JSON.stringify(oldOptions)) {\n      this.createOptionList();\n      this.reflectSelectedOptionsToComponent();\n    }\n  }\n  /**\n   * Triggered when option is selected. Event emitted in cwc-select-option\n   * @param event Event details\n   */\n\n\n  optionSelectedHandler(event) {\n    event.stopPropagation();\n    const optionsToBrowse = this.optionsAndHelpers();\n    const newSelectedOption = optionsToBrowse.filter(optionEl => JSON.stringify(optionEl.value) === JSON.stringify(event.detail.value))[0];\n\n    if (this.multiple) {\n      this.selectNewMultipleOption(event.detail);\n    } else if (newSelectedOption) {\n      this.selectNewSimpleOption(newSelectedOption, event.detail, !event.detail.selectedByProp);\n    }\n\n    this.updateTextInTheComponent(!event.detail.selectedByProp);\n  }\n  /**\n   * Listens to click outside the component and hides the dropdown options list if is currently shown\n   * @param event Event Details\n   */\n\n\n  handleClick(event) {\n    if (this.showDropdown && !this.host.contains(event.target)) {\n      this.closeDropdown();\n    }\n  }\n  /**\n   * Register option when it is hits the DOM.\n   * @param element The option element\n   */\n\n\n  registerOption(element) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      _this.allDropdownOptions.push(element);\n\n      _this.sortSelectOptions();\n\n      _this.checkPreselectedOptions();\n\n      _this.registerLabelFocusHandler();\n\n      _this.registerSelectAllOption();\n\n      _this.checkFooterSlot();\n\n      _this.checkSelectValue(_this.value, false);\n\n      _this.filterOptions(_this.filterValue); // if all options are selected, then selecct the select-all option as well\n      // setTimeout is needed to target the select-all checkbox correctly\n\n\n      setTimeout(() => _this.handleSelectAllCheckbox(), 1);\n    })();\n  }\n  /**\n   * Unregister option when it is removed from the DOM\n   * @param element The option element\n   */\n\n\n  unregisterOption(element) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      _this2.allDropdownOptions = _this2.allDropdownOptions.filter(optionEl => optionEl !== element);\n      _this2.selectedOptions = _this2.selectedOptions.filter(optionEl => JSON.stringify(optionEl.value) !== JSON.stringify(element.value));\n\n      _this2.updateTextInTheComponent(false);\n    })();\n  }\n  /**\n   * Set component value and emit cwcChange event. This is handy for emulating user input in automated testing tools.\n   * @param value New value\n   */\n\n\n  writeValue(value) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      _this3.checkSelectValue(value, true);\n    })();\n  }\n\n  componentWillLoad() {\n    initBasics(this); // Update the host if has dataList\n\n    this.createOptionList();\n  }\n\n  disconnectedCallback() {\n    destroyBasics(this);\n  }\n  /**\n   * Lifecycle hook - componentDidLoad\n   */\n\n\n  componentDidLoad() {\n    this.setSelectAllOptionElementDirection();\n  }\n\n  setSelectAllOptionElementDirection() {\n    if (this.selectAllOptionEl) {\n      this.selectAllOptionEl.rtl = this.rtl;\n    }\n  }\n\n  registerLabelFocusHandler() {\n    const selectInputEl = this.host.shadowRoot.querySelector('.cwc-select-control');\n\n    if (selectInputEl) {\n      selectInputEl.addEventListener('focus', () => {// this.onDropdownClick();\n      }, true);\n    }\n  }\n\n  registerSelectAllOption() {\n    if (this.selectAll && this.selectAllOptionEl) {\n      this.selectAllOptionEl.setOptionAsMultiple();\n    }\n  }\n\n  checkFooterSlot() {\n    const footerEl = this.host.querySelector('[slot=\"footer\"]');\n\n    if (footerEl && footerEl.innerHTML) {\n      this.showFooter = true;\n    }\n  }\n  /**\n   * Creates a SelectedOption object from an option-tag in the DOM.\n   * @param theElement an option tag\n   */\n\n\n  getElementAsSelectedOption(theElement) {\n    return {\n      name: theElement.textContent,\n      value: theElement.value\n    };\n  }\n  /**\n   * Select 'Select all' button if all options selected or unselect if not.\n   */\n\n\n  handleSelectAllCheckbox() {\n    if (this.multiple && this.selectAll) {\n      const selectAllCheckbox = this.selectAllOptionEl.shadowRoot.querySelector('cwc-checkbox');\n      const allDropDownsLength = this.getAllActiveDropDown().length;\n      const selectAllCheckboxChecked = this.selectedOptions.length === allDropDownsLength && allDropDownsLength > 0;\n\n      if (selectAllCheckbox) {\n        selectAllCheckbox.checked = selectAllCheckboxChecked;\n      } // If select-all is checked and select-all-message defined, then display the message in the select input\n\n\n      if (selectAllCheckboxChecked && this.selectAllMessage) {\n        this.setComponentTextValue(this.selectAllMessage);\n      }\n    }\n  }\n  /**\n   * Updates the text-box with the current selections and if set to true, emits a change-event with the\n   * new state.\n   */\n\n\n  updateTextInTheComponent(emitEvent = true) {\n    this.reflectSelectedOptionsToComponent();\n    this.handleSelectAllCheckbox();\n\n    if (emitEvent) {\n      if (this.controlValue) {\n        if (Array.isArray(this.controlValue)) {\n          this.controlValue.forEach(value => delete value['selectedByProp']);\n        } else {\n          delete this.controlValue['selectedByProp'];\n        }\n      }\n\n      this.debug && console.info('emitting cwcChange event', this.controlValue);\n\n      switch (this.returnedFormat) {\n        case EReturnFormat.OBJECT:\n          this.cwcChange.emit(this.controlValue);\n          break;\n\n        case EReturnFormat.ANY:\n          if (Array.isArray(this.controlValue)) {\n            this.cwcChange.emit(this.controlValue.map(value => value.value));\n          } else {\n            this.cwcChange.emit(this.controlValue.value);\n          }\n\n        case EReturnFormat.STRING:\n          if (Array.isArray(this.controlValue)) {\n            this.cwcChange.emit(this.controlValue.map(value => JSON.stringify(value.value)));\n          } else {\n            this.cwcChange.emit(JSON.stringify(this.controlValue.value));\n          }\n\n        default:\n          this.cwcChange.emit(this.controlValue);\n          break;\n      }\n    }\n  }\n  /**\n   * Whether a value has a matching cwc-option tag in this select.\n   * @param lookingFor a value to look for in the options for this select.\n   */\n\n\n  canBeFoundInTheOptions(lookingFor) {\n    return this.allDropdownOptions.findIndex(optionEl => JSON.stringify(optionEl.value) === lookingFor) !== -1;\n  }\n\n  sortSelectOptions() {\n    const optionsFromUI = Array.from(this.host.getElementsByTagName('cwc-select-option'));\n    this.allDropdownOptions.forEach(option => {\n      option['position'] = optionsFromUI.indexOf(option);\n    });\n    this.allDropdownOptions.sort((a, b) => a['position'] - b['position']);\n  }\n  /**\n   * Updates the text which shows the current selection from the options.\n   */\n\n\n  reflectSelectedOptionsToComponent() {\n    if (this.selectedOptions.length) {\n      const joinedNames = this.selectedOptions.map(option => option.name).join(', ');\n      this.setComponentTextValue(joinedNames);\n    } else {\n      this.setComponentTextValue(null);\n    } // when selectedOptions is an empty array, return null\n    // otherwise return array or object\n\n\n    this.controlValue = Array.isArray(this.selectedOptions) && this.selectedOptions.length === 0 ? null : this.multiple ? [...this.selectedOptions] : Object.assign({}, this.selectedOptions[0]);\n  }\n\n  setComponentTextValue(textValue) {\n    if (this.variant === 'no-border') {\n      this.labelValue = textValue && textValue.length > 1 ? textValue : this.placeholder;\n    } else {\n      this.labelValue = textValue;\n      this.host.shadowRoot.querySelector('.cwc-select-control').value = textValue;\n    }\n  }\n\n  selectNewSimpleOption(newSelectedOption, newOption, emitEvent) {\n    const isAlreadySelected = this.selectedOptions.some(option => JSON.stringify(option.value) === JSON.stringify(newOption.value));\n\n    if (isAlreadySelected || this.multiple && this.selectedOptions.length === 0 && emitEvent) {\n      newSelectedOption.unselectOption();\n      this.selectedOptions = [];\n      this.debug && console.info(`unselecting single option : `, newSelectedOption.value);\n    } else if (newSelectedOption.selected) {\n      this.unselectAllOtherSelectedOptions(newSelectedOption);\n      this.selectedOptions[0] = newOption;\n      this.debug && console.info(`unselecting all single options but : `, newSelectedOption.value);\n    }\n\n    this.closeDropdown();\n  }\n\n  selectNewMultipleOption(newOption) {\n    const isAlreadySelected = this.selectedOptions.some(option => JSON.stringify(option.value) === JSON.stringify(newOption.value));\n\n    if (isAlreadySelected) {\n      this.selectedOptions = this.selectedOptions.filter(option => JSON.stringify(option.value) !== JSON.stringify(newOption.value));\n      this.debug && console.info(`unselecting multiple option : `, newOption.value);\n    } else {\n      this.selectedOptions.push(newOption);\n      this.debug && console.info(`selecting multiple option : `, newOption.value);\n    }\n  }\n\n  unselectAllSelectedOptions(disableEmitEvent = true) {\n    this.allDropdownOptions.filter(optionEl => optionEl.selected === true).forEach(optionEl => {\n      if (!optionEl.disabled) {\n        optionEl.unselectOption(disableEmitEvent);\n      }\n    });\n    this.selectedOptions = [];\n  }\n\n  unselectAllOtherSelectedOptions(exceptionOption) {\n    this.allDropdownOptions.filter(optionEl => optionEl !== exceptionOption && optionEl.selected).map(optionEl => optionEl.unselectOption(true));\n  }\n\n  checkPreselectedOptions() {\n    const selectedOptions = this.allDropdownOptions.filter(optionEl => optionEl['selected'] || false);\n\n    if (selectedOptions) {\n      this.selectedOptions = Array.from(selectedOptions).map(selectedOption => this.getElementAsSelectedOption(selectedOption));\n    }\n\n    this.reflectSelectedOptionsToComponent();\n  }\n  /**\n   * In case select have predefined value, this will be reflected to the component and options\n   */\n\n\n  checkSelectValue(value, emitEvent = true) {\n    if (typeof value === 'undefined') {\n      return;\n    } // Reset the select when the value is null\n\n\n    if (value === null) {\n      this.unselectAllSelectedOptions(true);\n      this.updateTextInTheComponent(emitEvent);\n      return;\n    }\n\n    const workingValues = Array.isArray(value) ? value.map(item => JSON.stringify(item)) : [JSON.stringify(value)]; // We only want to update if all the selected values fall within\n    // the set of the existing drop-down options.  Otherwise, do nothing\n    // because the action is to select a non-existent item\n\n    if (workingValues && workingValues.every(this.canBeFoundInTheOptions, this)) {\n      // Set the active options based on the new value array\n      this.unselectAllSelectedOptions();\n\n      if (this.multiple) {\n        this.allDropdownOptions.filter(optionEl => workingValues.includes(JSON.stringify(optionEl.value)) && (!optionEl.disabled || optionEl.selected)).forEach(optionEl => {\n          this.addOptionToSelectedOptions(optionEl);\n        });\n      } else {\n        // This is a single select.  I don't care how any items you put into the value property,\n        // or how many matches there might be.  You're getting the first one of each and that's it.\n        const yourChoice = this.allDropdownOptions.filter(justOne => JSON.stringify(justOne.value) === workingValues[0])[0];\n\n        if (yourChoice !== undefined) {\n          this.addOptionToSelectedOptions(yourChoice);\n        }\n      }\n\n      this.updateTextInTheComponent(emitEvent);\n    }\n  }\n\n  addOptionToSelectedOptions(option, disableEmit = true) {\n    option.selectOption(disableEmit);\n    this.selectedOptions.push({\n      name: option.textContent,\n      value: option.value\n    });\n  }\n\n  onFilterValueChange(event) {\n    event.stopPropagation();\n    this.cwcFilter.emit(event.detail);\n    this.filterValue = event.detail;\n  }\n\n  filterOptions(query) {\n    if (!this.filter) return;\n    const lcQuery = query === null ? '' : query.toLowerCase();\n    const optionsToShow = this.allDropdownOptions.filter(optionElShow => optionElShow.textContent.toLowerCase().indexOf(lcQuery) > -1); // Hide all options\n\n    this.allDropdownOptions.forEach(optionEl => {\n      optionEl.hideOption();\n    }); // Show the options that meet the filter query criteria and highlight the filter characters in the options\n\n    optionsToShow.forEach(optionEl => {\n      optionEl.showOption();\n      optionEl.highlightText(lcQuery);\n    }); // Show 'No results' label\n\n    this.emptyFilter = optionsToShow.length === 0;\n  }\n  /**\n   * Return all active dropdown\n   */\n\n\n  getAllActiveDropDown() {\n    return this.allDropdownOptions.filter(dropDown => !dropDown.disabled);\n  }\n  /**\n   * Return true if all drop down selected\n   */\n\n\n  isSelectedAllDropDown() {\n    const allDropDownsLength = this.getAllActiveDropDown().length;\n    return this.selectedOptions.length === allDropDownsLength && allDropDownsLength > 0;\n  }\n\n  onSelectAllChange(event) {\n    event.stopPropagation();\n    const ifAllSelected = this.isSelectedAllDropDown();\n\n    if ((this.selectAllOptionEl.selected || !ifAllSelected) && !(this.selectAllOptionEl.selected && ifAllSelected)) {\n      // Select All\n      this.unselectAllSelectedOptions();\n      this.allDropdownOptions.forEach(optionEl => {\n        if (!optionEl.disabled || optionEl.selected) {\n          optionEl.selectOption(true);\n          this.selectedOptions.push({\n            name: optionEl.textContent,\n            value: optionEl.value\n          });\n        }\n      });\n    } else {\n      this.unselectAllSelectedOptions();\n    }\n\n    this.updateTextInTheComponent();\n  }\n\n  getKeystrokeFunction(key) {\n    const keys = new Map();\n    keys.set('ArrowDown', () => {\n      this.navigateList(true);\n    });\n    keys.set('ArrowUp', () => {\n      this.navigateList(false);\n    });\n    keys.set('Escape', () => {\n      this.closeDropdown();\n    });\n    keys.set('Space', () => {\n      if (!this.showDropdown) {\n        this.openDropdown();\n      } else {\n        this.selectFocused();\n      }\n    });\n    keys.set('Enter', () => {\n      if (!this.showDropdown) {\n        this.openDropdown();\n      } else {\n        this.selectFocused();\n      }\n    });\n    return keys.get(key);\n  }\n  /**\n   * Creates a new `CwcSelectOptionElement` and appends it to the `CwcSelect` element when the dataList attribute is set.\n   */\n\n\n  createOptionList() {\n    // we create the list of options\n    if (this.dataList.length) {\n      // clear the children of the host\n      this.host.textContent = ''; // we create the list of options with the dataList\n\n      this.dataList.forEach(option => {\n        const el = document.createElement('cwc-select-option');\n        el.value = option.value;\n        el.designVersion = this.designVersion;\n        el.selected = this.selectedOptions.some(selectedOption => JSON.stringify(selectedOption.value) === JSON.stringify(option.value));\n        el.innerHTML = option.name;\n\n        if (this.multiple) {\n          el.setOptionAsMultiple();\n        }\n\n        this.host.appendChild(el);\n      });\n    }\n  }\n  /**\n   * When the `CwcOverlay` is changed and the `CwcSelect` is not changed, we need to update the show dropdown property.\n   */\n\n\n  onChangeShowDropdown(event) {\n    if (event.detail !== this.showDropdown) {\n      if (this.showDropdown) {\n        this.closeDropdown();\n      }\n    }\n  }\n\n  render() {\n    // the filter to narrow down the options within the select\n    const optionsFilter = this.filter && h(\"div\", {\n      class: \"cwc-select-dd__filter\"\n    }, h(\"cwc-input\", {\n      \"leading-icon\": \"magnifier-glass\",\n      placeholder: this.filterPlaceholder,\n      \"debounce-time\": this.filterDebounceTime,\n      value: this.filterValue,\n      variant: \"single-line\",\n      onCwcChange: event => this.onFilterValueChange(event),\n      style: {\n        width: '100%'\n      },\n      nativeElementTabIndex: \"-1\",\n      unwrap: true,\n      mobile: this.mobile,\n      designVersion: this.designVersion\n    })); // when there's multiple selection there might be the possibility of selecting all options\n\n    const optionsSelectAll = this.selectAll && h(\"cwc-select-option\", {\n      ref: el => this.selectAllOptionEl = el,\n      value: \"cwc_select_all_value\",\n      onCwcSelectOptionSelected: event => this.onSelectAllChange(event),\n      designVersion: this.designVersion\n    }, this.selectAllLabel); // the actual options\n\n    const options = h(\"div\", {\n      class: \"cwc-select__options\",\n      role: \"listbox\"\n    }, this.emptyFilter && h(\"span\", {\n      class: \"no-results\"\n    }, this.filterNoResultsMessage), optionsSelectAll, h(\"slot\", null)); // the footer of the options\n\n    const optionsFooter = this.showFooter && h(\"div\", {\n      class: \"cwc-select-dd__footer\"\n    }, h(\"slot\", {\n      name: \"footer\"\n    })); // the dropdown layer of the select\n\n    const selectLayer = h(\"div\", {\n      slot: \"content\",\n      class: 'cwc-select-dd' + (this.unwrap ? ' cwc-select-dd--unwrapped' : '') + (this.variant === 'no-border' ? ' cwc-select-dd--no-border' : ''),\n      style: {\n        maxHeight: this.dropdownMaxHeight ? this.dropdownMaxHeight + `px` : 'auto'\n      }\n    }, optionsFilter, options, optionsFooter); // the select's clickable portion\n\n    const selectTarget = this.variant === 'regular' ? h(\"cwc-input\", {\n      label: this.label,\n      required: this.required,\n      value: this.labelValue,\n      onCwcChange: event => event.stopPropagation(),\n      \"trailing-icon\": this.trailingIcon,\n      placeholder: this.placeholder,\n      disabled: this.disabled,\n      status: this.status,\n      statusMessage: this.statusMessage,\n      loading: this.loading,\n      class: \"cwc-select-control\",\n      unwrap: true,\n      variant: \"select-box\",\n      slot: \"target\",\n      style: {\n        width: '100%'\n      },\n      onCwcFocus: this.onFocus,\n      onCwcBlur: this.onBlur,\n      onClick: this.toggleDropdown,\n      readonly: true,\n      mobile: this.mobile,\n      designVersion: this.designVersion\n    }) : this.variant === 'header' ? h(\"span\", {\n      slot: \"target\",\n      class: 'cwc-select-control cwc-select-control--header ' + (this.disabled ? ' disabled' : '') + (this.showDropdown ? ' open' : ''),\n      onClick: this.toggleDropdown\n    }, this.label) : h(\"span\", {\n      slot: \"target\",\n      class: 'cwc-select-control cwc-select-control--no-border ' + (this.disabled ? ' disabled' : '') + (this.showDropdown ? ' open' : ''),\n      onClick: this.toggleDropdown\n    }, this.labelValue); // all selects use overlay, so this is a must\n\n    const overlayComponent = h(\"cwc-overlay\", {\n      disabled: this.disabled,\n      noToggle: true,\n      height: this.height,\n      width: this.width,\n      minWidth: this.minWidth,\n      show: this.showDropdown,\n      style: this.variant === 'no-border' && this.unwrap ? {\n        maxHeight: '1rem'\n      } : {},\n      block: true,\n      designVersion: this.designVersion,\n      onCwcShow: e => this.onChangeShowDropdown(e)\n    }, selectTarget, selectLayer); // here we determine if the select wrapper is going to be a plain div\n    // or the form group (label, error, etc) depending on the unwrap parameter\n\n    const selectContents = this.unwrap ? h(\"div\", null, overlayComponent) : h(\"cwc-form-group\", {\n      label: this.label,\n      required: this.required,\n      status: this.status,\n      statusMessage: this.statusMessage,\n      slot: \"target\",\n      mobile: this.mobile,\n      designVersion: this.designVersion\n    }, overlayComponent); // return the select structure\n\n    return h(Host, null, h(\"div\", {\n      class: `cwc-select ${this.designVersion}`\n    }, selectContents));\n  }\n\n  get host() {\n    return getElement(this);\n  }\n\n  static get watchers() {\n    return {\n      \"value\": [\"setSelections\"],\n      \"multiple\": [\"changeMultiple\"],\n      \"allowUnselection\": [\"changeAllowUnselection\"],\n      \"filterValue\": [\"filterValueChanged\"],\n      \"selectAll\": [\"changeSelectAll\"],\n      \"rtl\": [\"changeRtl\"],\n      \"variant\": [\"changeVariant\"],\n      \"dataList\": [\"changedataList\"]\n    };\n  }\n\n  static get style() {\n    return \"\\@charset \\\"UTF-8\\\";*{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}:host{display:inline-block}::-webkit-scrollbar{width:16px}::-webkit-scrollbar-track{background:transparent}::-webkit-scrollbar-thumb{background-image:url(\\\"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iOCIgaGVpZ2h0PSI0IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxwYXRoIGQ9Ik0wIDRhNCA0IDAgMSAxIDggMEgweiIgZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBmaWxsLW9wYWNpdHk9Ii40Ii8+PC9zdmc+\\\"),url(\\\"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iOCIgaGVpZ2h0PSI0IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxwYXRoIGQ9Ik0wIDBhNCA0IDAgMSAwIDggMEgweiIgZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBmaWxsLW9wYWNpdHk9Ii40Ii8+PC9zdmc+\\\"),url(\\\"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iOCIgaGVpZ2h0PSI4IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxwYXRoIGZpbGw9IiMwMDAiIGQ9Ik0wIDBoOHY4SDB6IiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGZpbGwtb3BhY2l0eT0iLjQiLz48L3N2Zz4=\\\");background-repeat:no-repeat,no-repeat,no-repeat;background-position:top,bottom,50%;background-size:auto,auto,8px calc(100% - 8px)}::-webkit-scrollbar-thumb:hover{background-image:url(\\\"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iOCIgaGVpZ2h0PSI0IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxwYXRoIGQ9Ik0wIDRhNCA0IDAgMSAxIDggMEgweiIgZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBmaWxsLW9wYWNpdHk9Ii42Ii8+PC9zdmc+\\\"),url(\\\"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iOCIgaGVpZ2h0PSI0IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxwYXRoIGQ9Ik0wIDBhNCA0IDAgMSAwIDggMEgweiIgZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBmaWxsLW9wYWNpdHk9Ii42Ii8+PC9zdmc+\\\"),url(\\\"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iOCIgaGVpZ2h0PSI4IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxwYXRoIGZpbGw9IiMwMDAiIGQ9Ik0wIDBoOHY4SDB6IiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGZpbGwtb3BhY2l0eT0iLjYiLz48L3N2Zz4=\\\")}.cwc-select{position:relative}.cwc-select>cwc-form-group,.cwc-select>cwc-form-group cwc-overlay{width:100%}.cwc-select>cwc-form-group cwc-overlay>cwc-input{display:block!important;width:100%}.cwc-select-control--header,.cwc-select-control--no-border{position:relative;display:inline-block;padding-right:1.5rem;cursor:pointer;-webkit-box-sizing:border-box;box-sizing:border-box;overflow:hidden;text-overflow:ellipsis;max-width:100%;white-space:nowrap;line-height:1rem}.cwc-select-control--header.disabled,.cwc-select-control--no-border.disabled{cursor:default;color:var(--cwc-select-disabled-color,var(--cwc-color-elements-input-border,#adaebb))}.cwc-select-control--header.disabled:after,.cwc-select-control--header.disabled:before,.cwc-select-control--no-border.disabled:after,.cwc-select-control--no-border.disabled:before{color:var(--cwc-select-disabled-after-color,var(--cwc-color-elements-input-border,#adaebb))}.cwc-select-control--header:after,.cwc-select-control--no-border:after{font-family:dls-icons!important;content:\\\"\\\";color:var(--cwc-select-input-icon-color,var(--cwc-color-links,#3fa9f5));position:absolute;right:0;top:0;-webkit-transition:-webkit-transform .15s ease;transition:-webkit-transform .15s ease;transition:transform .15s ease;transition:transform .15s ease,-webkit-transform .15s ease}.cwc-select-control.open:after{-webkit-transform:rotate(180deg);transform:rotate(180deg)}.cwc-select-dd{display:-ms-flexbox;display:flex;-ms-flex-direction:column;flex-direction:column;width:100%;-webkit-box-sizing:border-box;box-sizing:border-box;height:100%;font-weight:400}.cwc-select-dd--no-border,.cwc-select-dd--unwrapped{margin-top:0}.cwc-select-dd.hidden{opacity:0;pointer-events:none}.cwc-select-dd__filter{background:var(--cwc-select-filter-background,var(--cwc-color-grayscale-white,#fff));margin:0 1rem;display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;-ms-flex:0 0 auto;flex:0 0 auto;width:calc(100% - 2rem);z-index:1}.cwc-select-dd__filter>*{width:100%}.cwc-select-dd__filter+.cwc-select__options .cwc-select__option:first-child{margin-top:0}.cwc-select-dd__filter-icon{color:var(--cwc-select-filter-icon-color,var(--cwc-color-links,#3fa9f5));padding-top:2px}.cwc-select-dd__footer{background:var(--cwc-select-footer-background,var(--cwc-color-grayscale-white,#fff));display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;-ms-flex:0 0 auto;flex:0 0 auto;position:relative;width:calc(100% - 2rem);z-index:1;bottom:0;border-top:.0625rem solid var(--cwc-select-footer-border-top,var(--cwc-color-elements-input-border,#adaebb));margin:0 1rem}.cwc-select-dd.filtered .cwc-select-dd__option.check-all{display:none}.cwc-select-dd .no-results{margin:0 1rem;display:block;color:var(--cwc-select-no-result-color,var(--cwc-color-grayscale-medium,#666));padding:.5rem 0}.cwc-select__options{overflow:auto;-ms-flex:1 1 auto;flex:1 1 auto}.cwc-select__options>slot{display:block}.cwc-select__select-all{padding:.25rem 0 0!important}.cwc-select__select-all:after{content:\\\" \\\";display:block;margin:0 1rem;height:0;border-bottom:1px solid var(--cwc-select-select-all-border-bottom,var(--cwc-color-elements-input-border,#adaebb))}[dir=rtl] .cwc-select-control--no-border{padding-right:0;padding-left:1.5rem}[dir=rtl] .cwc-select-control--no-border:after{right:auto;left:0}\";\n  }\n\n};\nexport { Select as cwc_select };","map":null,"metadata":{},"sourceType":"module"}