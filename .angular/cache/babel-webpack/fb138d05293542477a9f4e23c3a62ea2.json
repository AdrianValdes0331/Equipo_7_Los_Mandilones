{"ast":null,"code":"import { r as registerInstance, h, H as Host, g as getElement } from './core-85189c77.js';\nimport { q as queryShadowRoot, b as isFocusable, i as isHidden } from './index-eb5f436d.js';\nconst FocusTrap = class {\n  constructor(hostRef) {\n    registerInstance(this, hostRef);\n    /**\n     * Activates the focus trap and focuses the first focusable element.\n     */\n\n    this.active = false;\n    /**\n     * Focuses the first focusable element in the focus trap.\n     */\n\n    this.focusFirstElement = () => {\n      this.trapFocus();\n    };\n    /**\n     * Focuses on either the last or first focusable element.\n     */\n\n\n    this.trapFocus = () => {\n      const focusableChildren = this.getFocusableElements();\n\n      if (focusableChildren.length > 0) {\n        focusableChildren[0].focus({\n          preventScroll: false\n        });\n        this.backupElement.setAttribute('tabindex', '-1');\n      } else {\n        // If there are no focusable children we need to focus on the backup\n        // to trap the focus. This is a useful behavior if the focus trap is\n        // for example used in a dialog and we don't want the user to tab\n        // outside the dialog even though there are no focusable children\n        // in the dialog.\n        this.backupElement.setAttribute('tabindex', '0');\n        this.backupElement.focus();\n      }\n    };\n  }\n  /**\n   * Returns a list of the focusable children found within the element.\n   */\n\n\n  getFocusableElements() {\n    return queryShadowRoot(this.host, isHidden, isFocusable);\n  }\n\n  componentDidLoad() {\n    this.backupElement = this.host.shadowRoot.querySelector('#backup');\n    this.startElement = this.host.shadowRoot.querySelector('#start');\n    this.endElement = this.host.shadowRoot.querySelector('#end');\n    this.startElement.addEventListener('focus', this.focusFirstElement);\n    this.endElement.addEventListener('focus', this.focusFirstElement);\n  }\n\n  componentDidUpdate() {\n    this.active && this.startElement.focus();\n  }\n\n  disconnectedCallback() {\n    this.startElement && this.startElement.removeEventListener('focus', this.focusFirstElement);\n    this.endElement && this.endElement.removeEventListener('focus', this.focusFirstElement);\n  }\n\n  render() {\n    const tabindex = this.active ? '0' : '-1';\n    return h(Host, null, h(\"div\", {\n      id: \"start\",\n      tabindex: tabindex\n    }), h(\"slot\", null), h(\"div\", {\n      id: \"backup\"\n    }), h(\"div\", {\n      id: \"end\",\n      tabindex: tabindex\n    }));\n  }\n\n  get host() {\n    return getElement(this);\n  }\n\n  static get style() {\n    return \"*{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}:host{display:inline-block}\";\n  }\n\n};\nexport { FocusTrap as cwc_focus_trap };","map":null,"metadata":{},"sourceType":"module"}